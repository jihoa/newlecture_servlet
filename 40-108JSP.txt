40 JSP 시작하기

지난시간 까지는 자바를 이용해서 웹개발을 할때는 서블릿이라는 플랫폼을 이용해서 프로그램을 만들었는데 거기다가 하나 더붙일것이다. 알바생인 Jasper를 붙이자. 
Jasper를 이용해서 서블릿을 쉽게 만들어보자, 세상에서는 Jasper라고 안부르고 JSP라고 부른다.

JSP를 쓰면 이점이 뭘까? 왜 써야할까?

프로그램을 만들게되면 사용자에게 응답을하게되면서 결과물을 돌려줄텐데 웹문서로 결과물을 줄것이다.
SUM:12 이런식으로 간단한 형태의 문자열을 문서로 보내는거라면 JSP를 사용하지 않아도 된다.

복잡한형태에 HTML구문을 이용해서 브라우저에게 보여주고 브라우저는 HTML문서를 읽어서 복잡하게 보내준다.
HTML문서를 out.write를 이용해서 한줄한줄 보내줬었어야했다. 과거에는 이런 노가다성작업을 필요로했었다.
자바는 Jasper라는 알바생을 두고있다 jasper라는 알바생을 두고나서 프로그램을 만들게 되면 어떻게 달라지냐면
그냥 html문서를 주면 작업을 수행할수있다. html문서를 write를 붙여서 서블릿 문서로 만들어달라고 하면된다.
JSP에게 일을 어떻게 시킬까? 확장자만 jsp로 붙여주면된다. ex) add.jsp 

제스퍼는 언제 서블릿코드로 바꿔줄까. 사용자가 확장자를 갖고있는 페이지를 요청할때 바꿔준다. 또한 url매핑은 파일명 그대로 매핑이된다. servlet은 따로 매핑해서 파일명과 url이 다른경우가 있었지만 JSP같은경우는 파일명이 곧 url이다.
실제로 만들어진 서블릿코드는 add.jsp라는 이름을 갖지않고

톰캣 설치 디렉토리 아래에 add_jsp.java라는 이름을 갖게된다.
\work\Catalina\localhost\newlec\org\apache\jsp\add_jsp.java

calc3.html을 복사해서 calculator.jsp로 바꾸고 실행을 해보도록 하자. 잘실행이 된다. 특별하게 다를것은 없지않을까?라고 이야기할수있는데 
그렇지않다.
<td class="output" colspan="4">${3+4}</td> 
다름을 증명하기위해서 이렇게 바꿀것이다. 그냥 html이면 글자 그대로 나오게 될것이고 아니고 JSP이면 그 결과물 7을 출력하게 될것이다.
7을 제대로 출력했다. 분명히 서블릿코드로 만들었다. 

서블릿이라는 코드를 만들었다면 결과물을 볼수있을까?
서버탭에서 서버를 더블 클릭을하거나 서버에 오른쪽 마우스 오픈 누르면 되면 서버의 설정이 열리게된다.
한가지 알고있어야하는점은 우리는 코드를 이클립스안에 src나 webContent에서 코드를 만들고,파일을 추가하고나서, ctrl+f11을 눌러서 브라우저에서 열어보게 되는데 
처음 입문한사람이 착각하는것은 src나 WebContent가 홈브라우저 인줄 아는것이다. 서비스되고있는 파일이 그곳을 참고하는게아니다. 이곳은 개발할때 사용되는 개발디렉토리이다.
이것을 실행하겠다고하면 배포하게된다. 배포하게되면 톰캣의 홈디렉토리로 옮겨지게된다. 사용하고있는 톰캣이 실제 다른서비스를 운영할수있기때문에 실제톰캣의 워크디렉토리에두지않고
별도의 복사본 이클립스가 관리하는 별도의 운영을 위한 별도의 사본을 만들게된다. 그녀석은 Server Path에 있다.

workspace\metadata\plugins\wst.server.core\temp
안에 있다.
work는 제스퍼가 일하는 작업실이다. 제스퍼가 만들어낸 파일을 확인할수있다. 계속들어가보면 calculator_jsp.java라는 파일을 볼수있다 이파일이 제스퍼가 만든 파일이다.


JSP는 변경된 점이있으면 제스퍼는 다시 만들어준다 그래서 서버를 재시작할 필요가 없다. 


int x=3;
int y=4;
<li><label for ="x">X : </label><input name="x" /></li>
라는 코드를 작성했을때 int x =3; int y=4 ;도 JSP는 화면에 그냥 출력해버린다. 하지만 변수기 때문에 화면에 출력하면 안된다. 그냥 
그럴때는
<%
int x=3;
int y=4;
%>
<%%>: 코드블럭
를 붙여주면 코드다 서블릿 안에다 자바 코드를 넣는다는 의미이다. 이것이  서블릿이라는 녀석을 제스퍼로 통해서 만들어주는 방법이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

41 JSP의 코드 블록

지난시간에 JSP를 이용해서 서블릿코드를 간접적으로 만들어봤다. 왜 그랬을까? 문서를 출력할때 방대한 html을 출력해야하므로 out.write를 붙여야해서 단순하고 반복적인 작업이기 때문이다.
자바 코드를 끼워놓고싶다라고하면 자바코드를 끼워넣을수있는 코드블럭을 지시할수 있어야한다.

코드 블록 지시 방법에 대해서 알아보도록하자
<% X+Y=3 %>				//자바코드 실행됨 출력 X
y의 값은: <% out.print(y)%>			//y의 값은: y 		
y의 값은: <%=y %>			//y의 값은: y  위와 같은 결과가 나온다.

만약에 
public int sum(int a int b)
{
	return a+b;
}
이코드를 add.jsp에 멤버 메서드로 정의하고싶다. <% %>로 코드를 감싸면 에러가 난다. 왜냐면 일반적 코드블럭을 쓰게되면 서비스함수에 들어가게된다.

<%! %> 를 써주면 멤버변수에 들어가게 된다.

<%@ %>: 일반적으로 자바코드가 아니며, 페이지 지시자 블록, 키와 값으로 이뤄져있으며 페이지를 어떤형태의 인코딩방식, 컨텐트타입등등을 지시하는것이다.
 (지시블럭)
코드지시자를 통해서 쓰게되면 어떤코드보다도 앞서 진행된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

42 JSP의 내장객체 간단히 알아보기

JSP가 갖고있는 내장객체를 알아보자 JSP를 만들면서  page라는 변수를 선언하면 에러가난다.
왜냐면 코드블럭외에 코드가 있다는 뜻이다.JSP가 만들어낸 서블릿에서는 그런 변수들이 있을수 있다는 것이다.
확인해보니까 JSP는 서비스함수를 만들면서 자기가 필요한 변수를 만들어낸다. 그중에 page라는 변수가 있어서 에러가 나는것이다.

Jsp를 만들게되면 서블릿안에 변수들을 들여다 볼 필요가있다.

public void_jspService(final javax.servlet.http.HttpServletRequest request, final 
javax.servlet.http.HttpServletResponse response) 
	throw java.io.IOException, javax.servlet.ServletException{		//변수들은 객체를 가르치는 개체의 형식이다.
 		final javax.servlet.jsp.PageContext pageContext;
		javax.servlet.http.HttpSession session =null;
		final javax.servlet.ServletContext application;
		final javax.servlet.ServletConfig config;
		javax.servlet.jsp.JspWriter out = null;
		final java.lang.Object page=this;
		javax.servlet.jsp.JspWriter _jspx_out =null;
		javax.servlet.jsp.PageContext _jspx_page_context =null;

JSP에서 만들어놓은 변수들은 내장객체(built in object)라고 부른다.
-request				//입력 도구
-response				//출력 도구
-pageContext			// Session이나 Application처럼 페이지내에서 임시로 데이터를저장setattribute,getAttribute를 가진	pageContext는 내부에서만 사용함
-session				//session 객체 ServletContext는 전역적으로사용
-application			//application객체
-config		
-out				//출력 도구
-page 				//이 page의 객체를 참조하는  object형 page변수
이 녀석들은 우리들이 알아 놓아야한다. JSP에서 코드블럭을 만들때 적절히 활용해서 프로그램을 만들수있어야한다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

43 JSP로 만드는 Hello 서블릿

서블릿으로 처음만들었던코드가 Nana.java였다. 그것을 JSP로 만들어보자 WebContent에다가 jsp파일을 생성하고 nana.jsp 라고 이름을 붙여주자.
url에 매핑될예정이므로 소문자로 적는것이 바람직하다.

그리고 만들어진 JSP파일에다가 안녕 Servlet<br /> 만 추가해서 실행해보도록 하자 
안녕 Servlet이 정확하게 화면에 표시된것을 확인할수 있었다. 실제로 서블릿을 jsp의 도움을 받아서 만든것이다.

만약에 10번 반복하고싶으면 어떻게할까?
<body>
	for(int i=0; i<10; i++)
	안녕 Servlet<br />
</body>
그냥 이렇게 실행할시에 텍스트 그대로 출력되는것을 확인할 수있다.

<% for(int i=0; i<10; i++){%>		//for문이 어디서 어디까지인지 구분하기 위해 반드시 중괄호를 써줘야한다.
	안녕 Servlet<br />
	<%} %>			




최종-
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%

String temp = request.getParameter("cnt");	//내장객체 request를 사용했다.

int cnt=100;
if(temp != null && !temp.equals(""))
	cnt= Integer.parseInt(temp);

%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<% for(int i=0; i<cnt; i++){%>
	안녕 Servlet<br />
	<%} %>
</body>
</html>
과거에는 서블릿코드(nana.java)를 직접만들었지만 요즘에는 JSP를 이용해서 코드블럭만 책임지고 나머지는 JSP가 출력을해주기 때문에 출력이 많아질때 많은 도움을 받을수있다.
다음시간에는 JSP가 장점이 많지만 단점이 많아짐 요즘경향에서는 JSP를 출력을위한 부분에만 포커스를 맞춰서 템플릿 페이지로 바뀌고있다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

44 스파게티 코드를 만드는 JSP

초간단 JSP를 만들것이다. 오늘 JSP페이지를 만드는 이유는 JSP를 만드는 방법이 너무 다양해서 간단하게 만들수도있고 복잡하게만들수도있다.
복잡하게 만들었을때 스파게티 코드라고 부른다. 

spag.jsp라는 파일을 만들것인데 사용자가 숫자를 입력하면 홀수인지 짝수인지 돌려주도록 할것이다.
출력은 홀수입니다 or 짝수입니다 중 하나를 출력할것이다.

-spag.jsp
	<%if(){ %>
	홀수입니다
	<%}
	else
	 %>
	짝수입니다
	<%} %>

만약에 이렇게 작성해도 가독성이 좋지못하다. 

-spag.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
	int num = 0;
	String num_=request.getParameter("n");
	if(num_ != null && !num_.equals(""))
		num= Integer.parseInt(num_);
%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<%if(num %2 !=0){ %>
	홀수입니다
	<%}
	else
	{%>
	짝수입니다
	<%} %>
</body>
</html>
정말 간단한 예제이다.

코드블럭이라는것은 여러 블럭을 하나로 합쳐서 만든다고 생각이들정도로 같은 함수내에 있는 코드들이다.
위의 코드 처럼 나눠서 만들게 되면 코드를 수정할때 자바코드만 모아서 확인하기 어렵기때문에 그 코드블럭만 스크롤해서 보면서 어디가 에러났는지 어디서 어디까지 동일한 업무를 하는지 보기힘들다
실타래코드,스파게티코드: 한번 꼬이면 대책이없는 코드

이런코드를 지양하고 유지보수하기 쉽게하려면 한곳에다가 몰아야 쉽다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

45 JSP MVC model1

지난시간에 JSP페이지를 만들면서 JSP의 도움을 받아서 서블릿코드를 만들수있었다. 
JSP를 잘못만들게되면 코드블럭이 복잡해지는 문제가 있을수있겠다. 어떻게하면 코드블럭을 쉽게 만들수있을까?라는 고민을 하게된다.
간단하게 만들어봤음에도 불구하고 굉장히 복잡해보였다.

간편하게 만들수있는 방법이없을까하고 만든것이 mvc1방식이다.
mvc1: 코드라고 하는 녀석을 블럭을 최소화 하자는 그런것에서부터 시작을한다. 블럭을 최소화하게하면

-코드1

/*-------- 입력코드 --------*/
<%
String num_= request.getParameter("n");
%>


/*-------- 출력 코드 --------*/
<% if(num%2 !=0){ %>
	홀수입니다.
<% }else{ %>
	짝수입니다.
<% } %>


-코드2
/*-------- 입력코드 --------*/		Controller:입력과 제어를 담당
<%
String num_= request.getParameter("n");
...
if(num%2 !=0){
	model="홀수"		//출력할데이터를 변수화해서 데이터를 만들어낸다.	Model: 출력 데이터
}else{
	model="짝수"		//출력할데이터를 변수화해서 데이터를 만들어낸다.	Model: 출력 데이터
}
%>

/*-------- 출력 코드 --------*/		View: 출력담당(HTML)

<%=model %>입니다.



제어를할때 코드1처럼 출력을 제어하게 되면 코드블럭이 여러개가 생길수밖에없다. 그런데 코드2처럼 출력할데이터를 미리만들어내고 꽂아넣기만하면
코드블럭이 한곳에만 놓을수도있고 출력하는 부분도 굉장히 깔끔해질수있다.

코드 1을 코드2로 구현하기위해서 제어블럭이 올라갔다.코드 1에서는 출력을 제어했다면 코드2에서는 데이터를 제어하는것이다.
출력할 데이터가 모델이라고 한다면 출력할데이터를 만들어내는과정(입력과 제어를 담당):Controller 라고한다.

Controller:입력과 제어를 담당
Model: 출력 데이터
View: 출력담당(HTML)

MVC model1:코드를 모델을 이용해서 V와 C로 나눠서 만드는 방식을 생각하자.
모델1 방식을 만들때 가장중요하게 봐야하는것은 자바코드와  출력코드를 최대한 분리시키자. 그걸 가능하게 하기 위해서 모델이란 특수한 변수가 따로 사용되는데
적절하게 이용할수있으면, 출력코드로부터 컨트롤러 관련된 제어 관련된 코드를  몰아낼수있다. 코드 양분화 가능

-spag.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
	int num = 0;
	String num_=request.getParameter("n");
	if(num_ != null && !num_.equals(""))
		num= Integer.parseInt(num_);
	String result;
	
	if(num %2 !=0)
		result="홀수";
	else
		result="짝수";
	 %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<%=result %>입니다.
</body>
</html>

업무로직을 구성할때 훨씬 더 쉽게 유지 보수할수있다. 출력을 관리하는사람또한 자바코드가없으니까 훨씬더 쉽게 코드를 구성가능

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

46 JSP MVC model1을 model2 방식으로

오늘은 지난시간 설명했던 model1을 model2로 바꿔보자.

model 1: 컨트롤러와 뷰가 물리적으로 분리되지 않은 방식

전에 model1에서 프로그램을 만들때는 코드라는 블럭을 JSP 전체 영역에서 흩어서 사용하는것은 바람직하지 않다고 했다.
그래서 자바코드를 올렸다(controller). 그것이 가능하기 위해서는 model이라는 변수가 있어서 가능했다. 
출력을 위한 변수(model)을 준비하기 위한 코드가 위에 올려둔 자바코드(controller)에서 만들어지게 되고 그 model을 가지고 JSP에서 사용하게된다.

Controller를 JSP에 놓을지 아니면 분리할지를 생각해보자

아예 분리해서 Servlet으로 올려놓는 방법을 생각해보자 사용자의 요청이 있을때 Servlet으로 만들어지는것이 아니라 View단만 사용자의 요청이 있을떄 Servlet으로 만들어지니까
서블릿으로 만들 분량이 줄어들고 Controller단은 미리 컴파일해서 배치해놓을수 있기떄문에 실행속도가 개선될뿐만아니라 자바코드 작성하는 부분과 분리되있기때문에 유지보수가 간편해진다.
여러가지 장점이 많다. model2의 핵심이다.

model2에서는 Controller 와 View를 분리하는것이 핵심이다. 물리적으로 Controller와 View가 분리했는지에 따라서 model1과 model2 의 큰 차이이다.

Controoler에서 View를 연결하게 위해서 포워딩하는 방법이 포함된다 .Controller(서블릿)에서 View(jsp로 되어있지만 서블릿)에서 이전되면서 그흐름을 이어받아서
코드를 진행할때 사용되는것이 포워딩이라고 하는데 포워딩을 하게되면 Dispatcher를 통해서 포워딩을 하게된다.
View가 늘어나면 Controller로 도 같이 늘어날텐데 그럴때마다 컨트롤러는 Dispacher를 사용해서 포워딩하게된다.
그럼 어떻게 보면 모든 Controller가 갖고있는 공통적인 Dispatcher의 기능이 비효율적으로 보일수있다. Dispatcher라는 녀석을 하나만 두고 숫자의 컨트롤러의 기능만 담는녀석을 별도로 분리하는 작업을 한다.

실질적으로 (Dispatcher)서블릿은 하나만 만들고  일반적인 업무로직(Controller)는 POJO 클래스라고 해서 서블릿 클래스가 아닌 일반 클래스형태로 클래스를 만들어서 사용자 요청이 들어오게 되면
Dispatcher가 사용자 요청을 수반해서 적절한 컨트롤러를 찾아서 수행하게 하는 방식으로 진행을 한다.
그 사이 Controller 에서는 진행한 로직에 해당하는 뷰를 호출할수있도록 Dispatcher에게 관련된 내용을 알려주면 Dispatcher가 그걸가지고 호출하게되는 형태이다.

Model2는 지난번에 있는 예제와 비슷하다. 다만 물리적으로 분리되어있는가 아닌가의 차이이다.


-spag.java를 추가하자

package com.newlecture.web;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/spag")					//매핑을 해야하기때문에 매핑
public class Spag extends HttpServlet{				//서블릿 코드로 만들기 때문에 HttpServlet extends하자
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {		//doget이라는 메서드 오버라이드
		int num = 0;
		String num_=request.getParameter("n");
		if(num_ != null && !num_.equals(""))
			num= Integer.parseInt(num_);
		String result;
		
		if(num %2 !=0)
			result="홀수";
		else
			result="짝수"

		request.setAttribute("request", result);				//request에다가 SetAttribute result라고하면 result를 담겠다.꺼낼때는 request로 꺼내겠다.

		//redirect : 현재 작업한 내용과 전혀 상관없이 새로운 요청을 하게함
		//forward: 현재 작업한 내용을 이어갈수있도록 무언가를공유

		RequestDispatcher dispatcher
			= request.getRequestDispatcher("spag.jsp");		//우리가 하고싶은것은 포워딩이다. 그것을 하기위해 쓰는것이 getRequestDispatcher()이다. 괄호에 현재 Spag의 url을 요청했을때 요청을 spag.jsp로 전달하려고 경로를 넣었다. url상으로 같은디렉토리에 있다고 생각하기에 경로를 안넣음
		dispatcher.forward(request,response);				//forward의 특징은 괄호안에 현재 작업했던 내용을 담을수있다.request와 response도 공유가능 그내용들이 spag.jsp로 이어져서 요청이 진행됨 spag.jsp는 서블릿이기때문에 spag.jsp로 이어지면 request와 response가 똑같기 때문에 spag.java의 내용을 이어갈수있다.
									//forward 관계에 있는 둘 사이의 저장소로서 request가 사용된다.
									//어떤 상태를 사용할때 사용할수있는 저장소 4가지 			
									//1. 페이지 컨텍스트: 페이지 내에서 혼자 사용함
									//2. Request: 포워드 사이의 둘사이의 저장소
									//3. 세션: 세션에서 공유될수있는 저장소
									//4. (어플리케이션)페이지: 모든 세션 모든페이지에서 공유될수있는 저장소
									//쿠키 제외하고 서버상의 저장소는 4가지이다.
	}
}


-spag.jsp

<%=request.getAttribute("result") %>입니다.		//<%=result %>입니다. 에서 바꿈

실행할때는 무조건 컨트롤러인 spag.java(컨트롤러) 에서 실행해야한다. 컨트롤러가 데이터를 만들어야 출력할것이 있기때문이다.

모델 1 => 모델2 
물리적으로 완전히 코드가 분리되었다. 한쪽은 컨트롤러는 새로운 클래서에다가 서블릿으로 담당하게된다. 한쪽은 view단(html)
아직 프론트 컨트롤을 분리하지않았다.
뷰단에서 아직 완전하게 자바 코드가 사라지지않았다. 완전히 몰아내는 방법을 알기위해 EL을 배우도록 할것이다.
<%=request.getAttribute("result") %>입니다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

47 EL(Expression Language)

JSP를 mvc방식으로 만들때 아주 요긴하게 쓸수있는 EL이라는 표기언어에 대해서 알아보자

Controller  			=>			View
request.setAttribute("cnt",30);	=>		request.getAttribute("cnt",30);

EL 사용시
				=>		${cnt}
				
MVC방식으로 만들다보면 Controller에서는 데이터를 가공하고 가공한 녀석을 request라는 저장소에다 담아서
View에서 사용한다. view에서 사용하기위해서 자바코드를 사용하게되는 문제가 발생하게 된다. View에서는 자바코드를 사용하지 않게하는 방식으로 가는것이
Mvc구현하는데 가장 좋은 방법이다. request에 담았으니까 view에서 사용하기위해서 request.getAttribute()를 사용했다.
이걸 쉽게하는 방법이없을까? 이 자바코드라는것을 들어내고 자바코드 대신할수있는 표기법은 없을까? JSP에는 EL이라는것이 뒤늦게 합류했다.

지난시간에 사용했던 코드에서는 컨트롤러가 request에다가 result라는 값을 키워드로 해서 심어놨다.
request는 view와 controller가 공유하는것이다. 왜냐면 포워드 관계에 있기 때문이다.

<%=request.getAttribute("result") %>// request를 꺼내서 <%=%> 로 출력했다.

이것을 쉽게 대체할수있다. 출력하기위해 복잡한 코드블럭을 사용하지않고 아래와 같이 표현할것이다.

${result}

만약에 복잡한 데이터를 심고 꺼낼때는 어떻게할까? List 또는 배열의 값을 뽑는 방법도 알아야한다.

Controller  			=>			View
List list = new ArrayList(){"1",	"test"..};	=>		((List)request.getAttribute("list")).get(0)		//0번째를 꺼낸다고한다면 getAttribute할때 object형태로 반환하는데 get메소드를 쓸수가 없기때문에 list형으로 형변환하고 get(0)을 한다.
request.setAttribute("list",list);	=>

EL 사용시	
				=>			${list[0]}

담겨지는것이 Array나 list일때 역시도 훨씬 쉽게 꺼낼수있다.
Map과 object 객체를 심었다고하면 어떻게 꺼낼까?
Controller  			=>			View
Map n = new HashMap("title","제목");	=>		((Map)request.getAttribute("n")).get("title")	
request.setAttribute("n",n);		=>

EL 사용시	
				=>			${n.title]}

담겨진 객체또는 데이터 또는 일반적인값을 뽑았을때 자바 코드블럭을 사용하지 않고도 EL이라는 표기법을 이용해 쓸수있다는것은좋다
EL을 쓸때 저장소에서 꺼내서 쓰는데 저장소라는 녀석과 저장소에대한 우선순위를 알아야한다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

48 EL의 데이터 저장소

EL을 꺼내기위해서 사용할수 있는 저장소를 알아보자

page					//jsp내에서 제스퍼가 만들어낸 객체 pageContext: 페이지 내에서 사용할수있는 session,application 등등 페이지 단위로 데이터 저장소 역할이 가능하다.
request					//forward를 이용해서 두개의 서블릿이 값을 공유할때 사용할수 있음
session
application

page는 지난시간에 이해를 위해 사용했던 마지막 예제인데
JSP는 가지고 있는 내장객체 중에 pageContext 가 있다.
pageContext.getResponse
pageContext.getSession
등등을 얻어낼수 있다. 이런 객체를 얻어낼수 있는 보따리라고 한다면
pageContext.setAttribute("aa","Hello");			//이런 목적으로 사용할수도 있다. 값을 심는용도

페이지 내에서 여기에 심었던 데이터를 쓸수있다. 페이지내에서 저장소를 쓸수있는 객체를 페이지 객체라고 말한다.
페이지 객체로 담는 녀석도 ${cnt} 를 통해서 사용할수 있다.

여기서 궁금한점이 생기는데 ${cnt}에 있는 키워드로 값을 뽑아내려고하는데 page에도 cnt가 있고 request에도 cnt가있고 session에도 cnt가있다면 application 에도 cnt가 있다면
그렇다면 이 ${cnt} 키워드는 어디서 가져올까?

EL이 첫번째로 확인하는 공간은 Page이다. Page에서 찾으면 그 뒤는 찾지 않는다.
없다면 request,session,application 순서대로 찾는다.

내가 특정지어서 다른거 뒤지지말고 특정지은곳에서만 찾아라 할때는 Scope를 사용한다.
모든 저장소에서 뒤지지않고 특정한 위치에 있는 저장소만 찾고싶으면 Scope라는 한정사를 이용한다.
${sessionScope.cnt}

한정사여서 Session의 기능을 사용할수는 없다.
이렇게 저장소라는 녀석을 Scope를 가지고 사용하는 방법을 알아봤다.

4대저장소를 가지고 EL표기를 쓸수있지만 EL표기는 4대저장소 이외에도 쓸수있는 다양한 객체가 있다.

param
paramsValues					${param.cnt}		//parameter를 controller의 자바코드로 얻어낼수도있지만 view단에서 얻어내려면 쉽게얻을수있다.
header				=>		${header.host}		
headerValues					${header["host"]}		//header. 을 쓸수있는 내용이 변수 명명 규칙에 맞지않으면 대괄호를 이용해서 문자형식으로 쓸수있다. 안맞는 경우는 특수문자 "" / 등등이다.
cookie
initParam

헤더정보를 뷰단에서 뽑아올수있다 .개발자 도구에 Request Header 아래에 있는 항목을 가져올수있다.

pageContext를 이용할수있는데 PageContext는 좀 특이하다.
<%=pageContext.getRequest().getMethod()%>		//그안의 객체를 얻을때는 getter를 써야한다. 
EL에서는 함수를 호출하는 방식으로는 뭔가를 사용할수 없다. 모든것을 속성을 쓰는것처럼 써야하는데 재밌게도 Pagecontext다음에 getter는 사용할수있다. get은 빼고 대문자는 소문자로 바꾸고 함수호출이아닌것처럼 괄호는 빼야한다.

<%=pageContext.getRequest().getMethod()%>	=>  ${pageContext.request.method}	//EL에서는 getter를 사용할수있지만 getter가아닌 소스처럼 객체를 얻거나 메스드를 호출할수있다는점을 기억하자


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

49 EL 연산자

EL연산자에 대해서 알아보자
[].
()
not ! empty
* / div % mod
+ -
< > <= >= lt gt le ge		//lt: less than gt:greater than 
== != eq ne
&& and
|| or
? :

부등호나 lt gt le ge 를 사용하면 반환값은 True or False 이다.
왜 >< 부등호 연산자가 있는데 lt gt le ge 를 사용해야할까?
그 이유는 html자체가 <>를 사용하기 때문이다. 따라서 EL 표기법 안에서 <>를 사용하는것은 바람직 하지 않다.
html엄격한 구문으로 지정하게되면 오류를 유발할수 있기때문이다. xml 기반으로하면 허용하지 않을수 있다.
기본적인 html에서는 편한것 쓰는것이 좋다 사용이 불가능한 환경이면 lt gt le gt 를 사용하자

empty는 굉장히 많이쓰는 연산자이다.
언제 쓰냐면 ${param.n}에서 n이 전달되었다면 null이 올것이고 n이 전달되었는데 값을 전달하지않았으면 빈문자열이 올것이다.
${empty param.n} 			//null과 빈문자열 둘다 참이다. 
이것과 비슷한 연산은
${param.n==null || param.n== ''} 	//이렇게도 표현이 가능하다.

${empty param.n? '값이 비어있습니다.' : param.n} 	//삼항연산자를 이용해 비어있으면 비어있다고 출력 아니면 값을 출력하는것도 가능하다.

${param.n/2}  			// param.n/2로나누면 3을2로나눈것이다 1.5가 될것이다. 아니면 정수를 정수로 나눠서 1이될지 아니면 문자열 변환안되서 오류가날지 예측해보자
				//1.5 가 출력되었다. 정수라고 하는 녀석을 정수로 나눠도 결과는 소수점이 나온다. 소수점을 떼어내고 정수로만 쓰고싶다면 특별한방법을 써야한다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

50 수업용 프로젝트 준비하기

지난시간까지 서블릿과 JSP에 기본적인것들을 배웠다.
HTML을 다운받고 간단하게 사용하려고한다. 

다운로드 링크:http://www.newlecture.com/customer/notice/9
다운받아서 압축풀고 
WebContent 아래에 붙여놓도록 하자

준비해야할점 데이터베이스 ORACLE을 가지고 할것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

51 JSP를 이용해서 자바 웹 프로그램 만들기 시작

JSP를 이용해서 웹 프로그램을 만드는 방법을 시작할것이다. 시작하기에 앞서서 두가지를 알고있어야한다.

1. JSP를 이용해서 서블릿 프로그램을 만든다라고하면 그JSP를 이용해서 만드는 이유, 필요성
2. JSP를 이용해서 만드는 방법을 알아야한다.

서블릿 코드를 직접 만들수있지만 JSP를 이용해서 간접적으로 만들것이다. 출력하는 문서가 일반적으로 Html코드를 가지고있다. 정적인 내용을갖고있다는뜻
정적인 내용을 출력할때는 자바코드가지고 out.write를 직접해야하는데 비효율적이다. 필요에따라서 자바코드만 꽂아서 출력할수있도록 하겠다.
제스퍼에게 지시하도록 사용하는것이 JSP이다.

JSP를 이용해서 프로그램을 만든다고 한다면 서블릿을 직접 손대지 않겠다는 뜻이다. 서블릿을 직접손대지않고  자바코드를 꽂으려면 코드블럭을 사용해야한다.

JSP를 쓰는이유
out.write로 정적인 문서를 출력하지않고 코드블럭만 적절하게 꽂아서 만들려고 쓴다.

코드블럭의 종류
<%  %>					// 일반적인 로직을 작성하는 코드블럭
<%! %>					// 출력을 위한 코드블럭
<%= %>					// 멤버변수, 멤버함수를 정의하기위한 코드블럭
<%@ %>					// 자바코드x 지시를 하기위한 코드블럭

이걸 이용해서 웹프로그램을 만들려고하겠지만 확장자는 JSP 이지만 결과물은 서블릿이다.

JSP로 만들때 무조건 넣게되는것 
출력을 위한 지시자로 한글을 사용할때 이걸 안쓰면 한글이 다깨져서 보인다.

<%@ page language="java" contentType="text/html;charset=UTF=8"pageEncoding="UTF-8" %>

html-> jsp로 바꾸는 과정

html파일을 복붙해서 확장자를 .jsp 를 붙인다 그러면 한글이 다 깨져있다. 아무것도 손대지 말고 UTF파일을 복붙했더니 기본적으로 복붙한파일이 iso8859로 되있는데 UTF로 돌려야한다.
Alt+ENTER를 눌러서 UTF-8로 고치자
그러면 한글이 살아날것이다. 이걸로 끝이아니라 요청하게되면 서비스가 실행되게 되고 한글이 다 깨질것이다. 왜냐면 Servlet이기 때문이다. 보이기에는 html문서랑 똑같지만
out.write()가 다붙여져서 만들어진 코드로 JSP에의해서 만들어질것이다. out.write할때 인코딩하는 방식을 설정해줘야한다. 그때 UTF8로 설정해야함
그리고 맨위에다가  <%@ page language="java" contentType="text/html;charset=UTF=8"pageEncoding="UTF-8" %> 적어주자

근데 이것을 외워야될 필요가없다. 그래서 쓰는 방법은 파일을 jsp 파일을 만들어서 보면 맨위에 코드블럭이 있다. 그걸 사용해도된다.
코드블럭을 적절하게 이용할수 있으면 jsp를 이용해서 서블릿을 만들 수있는 능력이 되는것이다.

다음시간에는 정적인 내용이아니라 데이터베이스에서 값을 읽어와서 값을 출력할것이다.
DB가 준비되어있어야한다. Oracle로 사용할것이고 수업시간에했던 notice member 테이블사용할것이다.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

52 JDBC를 이용해 글 목록 구현하기

데이터베이스에 있는 목록을 가져다가 글 목록을 채우는 작업을 알아보려고한다. 

		<% 
		String url = "jdbc:oracle:thin:@192.168.77.1:1521/xepdb1";
		String sql = "SELECT * FROM NOTICE";
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		Connection con= DriverManager.getConnection(url,"NEWLEC","1234");
		Statement st = con.createStatement();
		ResultSet rs= st.executeQuery(sql);
		%>

복사해서 데이터베이스를 사용할 JSP에다가 코드 상단에 코드블럭을 만들고 붙여넣기 해준다.

맨 아래에도 종료하는 쿼리를 적어주자.

    	<% 
	rs.close();
	st.close();
	con.close();
	%>
이렇게 하게되면 Connection Statement ResultSet에 빨간줄이 그이게 된다. import를 안해서 그렇다. 자바때와 똑같이 ctrl+spacebar를 눌러서 임포트해주자
<%@page import="java.sql.Connection"%>	//페이지 지시자를 통해서 임포트에다가 넣어달라고 말하는것이다.

<% while(rs.next()){ %>
							
		<tr>
			<td> <%=rs.getInt("ID")%> </td>
			<td class="title indent text-align-left"><a href="detail.html"><%= rs.getString("TITLE") %></a></td>
			<td><%=rs.getString("WRITER_ID") %></td>
			<td>
				<%=rs.getDate("REGDATE")%>	
			</td>
			<td><%=rs.getInt("HIT")%></td>
		</tr>
					
<% } %>

이렇게 적어주고 실행하게되면 java.lang.ClassNotFoundException:oracle.jdbc.driver.OracleDriver 에러가 발생한다.
클래스가 없다는것이다. JDBC를 사용하려면 JDBC Driver를 사용해야하는데 저번시간에 사용했던 드라이버는 external jar로 설정했는데 안해서 그렇다.
 Build Path에다가 원래 설정했었는데 웹프로젝트는 그렇게하면안된다.
웹개발할때는  프로젝트에서 실행하고 배포하는것이아니다. 톰캣이하는것이다. 웹개발할때는 웹에서 사용하는 라이브러리가 어딘가로 배포되어 사용되기때문에
라이브러리를 같이가져가야한다. 라이브러리는 단순하게 jar파일이 어디있습니다. 라고 하는 경로를 지정하는 Build Path를 설정하는것이아니라.
라이브러리를 포함해야한다.
WEB-INF안에 lib에다가 jar파일을 담아야한다. 물론 Java실행환경이나 톰캣라이브러리는 담지않아도 된다. ojdbc.jar파일을 lib에 넣고 실행하니까 에러가 없어졌다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

53 자세한 페이지 구현하기

JDBC를 이용해서 오라클 서버에 있는 목록 페이지를 구현해봤다. 그 다음 구현할 내용은 자세한 페이지를 구현할것이다.
자세한 페이지 만들때 중요한점이있는데 , 자세한페이지를 갈때는 detail.jsp?id=9 이런식으로 9번에 대한 아이디에 해당하는 페이지로 간다는것이다.
id라는 값을 전달하지않으면 오류가 나야할것이다. 그러면 id값을 어떻게 심을수 있을까?

<td class="title indent text-align-left"><a href="detail.jsp?id=<%=rs.getInt("ID")%>"><%= rs.getString("TITLE") %></a></td>
이런식으로 값을 심을수 있다.

String sql = "SELECT * FROM NOTICE WHERE ID=?";
? 형태의 값을 채울수 있도록 하는 스테이트먼트가 따로있다. 그것을 PreparedStatement라고한다. 
원래 Statement인 Statement st = con.createStatement();
는 실행도구의 의무를 가장크게 가지고있는데 PreparedStatement라고 하면 얘기가 달라진다.

PreparedStatement st = con.prepareStatement(sql);
쿼리문을 넘겨받은다음에 실행할때는 미리 준비한 쿼리문을 실어서 실행한다.
ResultSet rs= st.executeQuery();

그래서 실행할때는 미리준비한 쿼리문을 실행하기때문에 executeQuery에 sql을 넣으면 안된다. preparedStatement에는 미리 준비하는 능력이 있기때문이다.
미리 준비한다는것은 물음표가 있어서 그 물음표를 채우기 위한 능력이 포함된것이다.

st.setInt(1,id); 	//첫번째 인자: 첫번째, 두번째인자: 무엇을 꽂아넣을건지 id를 꽂아놓을것이다.
rs.next();		//서버에서 레코드 하나를 가져오는것이고 그걸 사용하면된다.

<% 
	int id = Integer.parseInt(request.getParameter("id"));
    
String url = "jdbc:oracle:thin:@192.168.77.1:1521/xepdb1";
String sql = "SELECT * FROM NOTICE WHERE ID=?";

Class.forName("oracle.jdbc.driver.OracleDriver");
Connection con= DriverManager.getConnection(url,"NEWLEC","1234");
PreparedStatement st = con.prepareStatement(sql);
st.setInt(1,id);
ResultSet rs= st.executeQuery();

rs.next();

%>    

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

54 자세한 페이지 MVC model1으로 변경하기

저번시간에 작성한 코드는 스파게티 코드로 작성이 되었다. 하지만 유지보수하는데 어려움을 겪을 수 있으니 mvc1으로 만들자,
위에는 코드블럭을 한곳으로 모으고 아래는 순수한 html으로 모아야한다. 
code ,title,writer (최소한의 변수: model) 을 이용해서 Controller JAVA코드, View HTML코드로 나눌것이다.

만드는 방법 
1. 코드블럭을 맨위로 모은다.
2.  java와 html 로 나뉘었으면 model이 필요하다. Java 코드인 Controller에서 html에서 사용할 변수를 준비하는과정이다.
변수로 등록

							모델로 변환
<%= rs.getString("TITLE") %>		=>	String title=rs.getString("TITLE");




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

55 MVC model2 방식으로 변경하기

mvc의 또다른 방식 mvc2로 했을때 어떤차이가 있는 지알아보자
mvc2는 controller와 view를 물리적으로 분리하는것이다. 그러면 model은 어떻게 공유할것인가에 대한 문제가 남아있다.
물리적으로 나누면 장점이있을까? 
복잡도는 높아진다(단점) 
나눠서 만들면 개별적으로 관리가 된다(장점)
따로제작도 가능해짐 (장점)
실행할때도 요청이오면 자바코드는 미리컴파일해둘수 있어서 빠르다(장점)

model2로 만들때 상태저장 방법이 필요할텐데 객체가 4개가있다.( PageContext는 안되고 request가 가장적합하다. session application도 있다.)
request는 원래 입력도구인데 저장소로 쓸수도있다.

만드는과정
1.클래스 생성후 클래스 뒤에 extends HttpServlet붙임
2. 서비스 함수를 추가할텐데 서비스라고 하는 녀석을 추가할것인지, Get요청 특화된녀석을 쓸것인지 가능하면 Get요청 쓰자
3.super.doGet() 지우기 , req,resp를 이름을 request,response로 바꿔주기
2. WebServlet() 		//어노테이션 붙임
5. 그리고 원래 Controller부분 가져오기
6. import 하기
7. import 후 에러는 try catch가 없어서 그렇다. 하나만 마우스 갖다대고 예외처리
8. 그리고 밑에것들 복붙

9.서블릿(Controller) 에서 서블릿(View)로 전이 할수있는 방법은 두가지
-1. Redirect			// 호출했는데 아예 다른페이지로 가버리는것 게시글 등록후 목록페이지로 전이
-2. forward			// 작업했던 내용들 이어가려고 하는 전이방식

forward하는 방식에 dispatcher가 있는데 request를 통해서 얻을수있다. 경로는 홈디렉터리 기준으로 찾는다. request와 response를 공유한다.
		request.getRequestDispatcher("/notice/detail.jsp").forward(request, response);

detail.jsp를 요청하면서 현재 사용하고있는 저장소객체(request)와 출력도구(response)를 공유하겠다. 
10. request.setAttribute("title", title);		//request를 저장소로 사용해서 setAttribute로 값을 심어서 사용하자 

11. view에서 꺼낼때는 <%=request.getAttribute("title") %> 이런형식으로 꺼내기 더쉽게 꺼내는 방법은 다음시간에 배울것!

실무(현장)에서는 mvc2를 좀더 많이사용함 왜냐면 장점이 더많기 때문에
 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

56 Model 데이터를 구조화하기

코드를 또한번 변화시킬것이다. controller와 view단을 나눴었다. 꼭 나누지않아도된다. 숙련도에따라 상황에따라 그때 맞게해야한다.
만드는 방법은 만드는 사람이 어떤방법이 유지보수하기 편하다에 따라 달라지는 것인데 일반적인 기업용은 나누는 것을 좋아한다.
데이터를 구조화 하지않았기때문에 마무리 하지않았다.

개념적으로 말할수있는 데이터의 집합 엔티티(개체) 라고 한다.
데이터를 낱개로 보기보다 묶어서 사용하는것을 좋아한다.

			request.setAttribute("title", title);
			request.setAttribute("writerId", writerId);
			request.setAttribute("regdate", regdate);
			request.setAttribute("hit", hit);
			request.setAttribute("files", files);
			request.setAttribute("content", content);
이런데이터들을 한단어로 표현하면 공지사항이라고 할수있다.
묶어서 
request.addAttribute("n",notice);	로 하나로 묶을수가 있다.

-Notice.java

public class Notice {
	private int id;
	private String title;
	private String writerId;
	private Date regdate; 
	private String hit;
	private String files;
	private String content;
	//데이터를 채우기위해 세터를 준비할텐데 그거보다는 생성자를 준비해서 생성자로 채우자
	//마운스 오른쪽 source=> generate construct using Field
	//오버로드 생성자가 생성됨 그러면 기본생성자를 생성할것인지 말것인지 판단해야함 컴파일러가 안만들어주니까 기본생성자 추가하기위해 ctrl space누르면 기본생성자를 생성할수있다.
	
	public Notice() {
		// TODO Auto-generated constructor stub
	}
	public Notice(int id, String title, String writerId, Date regdate, String hit, String files, String content) {
		this.id = id;
		this.title = title;
		this.writerId = writerId;
		this.regdate = regdate;
		this.hit = hit;
		this.files = files;
		this.content = content;
	}
	//source=> Generate Getters and Setters 에서 모두선택
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getTitle() {
		return title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getWriterId() {
		return writerId;
	}
	public void setWriterId(String writerId) {
		this.writerId = writerId;
	}
	public Date getRegdate() {
		return regdate;
	}
	public void setRegdate(Date regdate) {
		this.regdate = regdate;
	}
	public String getHit() {
		return hit;
	}
	public void setHit(String hit) {
		this.hit = hit;
	}
	public String getFiles() {
		return files;
	}
	public void setFiles(String files) {
		this.files = files;
	}
	public String getContent() {
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}  
	//나중에 가지고있는 값을 테스트해보고싶으면 toString을 오버라이드해서 바꿔주면된다
	//source=> Generate toString 에서 모두선택
	//컬럼들을 출력하는 방식으로 오버라이드 해준다. 나중에 요긴하게 출력해볼수있음
	@Override
	public String toString() {
		return "Notice [id=" + id + ", title=" + title + ", writerId=" + writerId + ", regdate=" + regdate + ", hit="
				+ hit + ", files=" + files + ", content=" + content + "]";
	}
}

view단에서 받을때는 간단하게 EL을 사용해서 표현할수있다.  ${n.title}

Getters Setters 쓰는이유
-캡슐을 건드리지 않고 간접적으로 쓰기위해서
즉 필드들은 private 접근 제한자로 막아두고, 각 필드의 Getter,Settewr로 접근하는 방식을 취하자.
Getter,Setter는 클래스의 특성중 정보 은닉을 잘보여줌
이렇게하는 이유는 객체의 무결성을 보장하기위해서이다. 
객체가 가지고있는 로직을 무시하고 만드는 경우를 방지하기위해서

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
57 목록 페이지도 MVC model2로 수정하기

list.jsp의 코드를 mvc의 형태로 만들것이다. mvc로 만들때 가장 중요한점은 view(html)와 cotroller(java)코드를 분리하는것이 중요하다.
Controller에서 중요한것은 model을 만들어서 view단으로 보내야한다.

-NoticeControler.java
List<Notice> list = new ArrayList<>;		//노티스 객체 여러개 가지고있어야하므로 arrayList객체를 만든다.


-list.jsp
<%											//아직 반복문을  자바코드블럭외에 사용하는 방법을 안배웠기 때문에 코드블럭을 사용한다. EL에는 반복기능 없다.
List<Notice> list = (List<Notice>)request.getAttribute("list");					// list라는 녀석을 사용할수없다 (지역변수가 없기때문에) request라는 녀석에게서 꺼내온다(getAttribute). object로 뽑아지는 녀석을 list로 형변환해준다.
for(Notice n : list) {										// for문이 아니라 foreach문이다. 	
	pageContext.setAttribute("n", n);							// for문돌면서 임시로 저장할 저장소는 request,session,page,application 중에 page가 적합하다. 저장소에다가 n이라는 키워드를 사용할수 있게되었다.
%>											
<tr>													
	<td>${n.id}</td>									//${n.id} 여기서 n이라는 키워드는 지역변수가 아니라 저장소에 저장되어있는 키워드이다.											
	<td class="title indent text-align-left"><a href="detail?id=${n.id}">${n.title}</a></td>					
	<td>${n.writerId}</td>											
	<td>${n.regdate}</td>									
	<td>${n.hit}</td>											
</tr>
<%} %>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

58 View 페이지 은닉하기

view에서 실행하고싶으면 에러가 난다.  실행은 controller에서 실행해서 view가 실행해야한다.
이 view 파일이 notice/list.jsp 즉, 사용자가 요청할 수 있는 폴더에 들어가있다. 하지만 뷰는 더이상 사용자가 직접 요청하면 안되는 페이지이다. 
이녀석은 컨트롤러를 통해서 출력할 일이 있을때 이제 컨트롤러가 선택적으로 실행할수 있어야한다.
출력이 귀찮아서 출력에 복잡도가 높아서이다.

View단은 사용자가 요청할수 없도록 두는게 제일 바람직하다. 
어떻게 하면좋을까? 비공개 영역에다가 두면된다. WEB-INF: 외부에 서비스되지않는 파일들이있을수있다. 설정파일등을 둔다. 라이브러리, 코드파일 등등
View 페이지역시도 여기에다가 둘것이다.

WEB-INF 아래에 View 라는 폴더를 만들어주자. 그리고 뷰단에 해당하는 폴더들을 여기에다가 넣어주자. admin,member,notice,student

고쳐야할것이있다. controller 두개를 만들었는데 경로를 바꿔야한다. 
"/WEB-INF/view/notice/list.jsp"


설정이 완료되고나서 
http://localhost:8080/WEB-INF/view/notice/list.jsp 를 직접 요청하게 되면 어떻게 될까?

404 에러 서버에서 제공되지 않은 페이지 또는 서버에서 그페이지를 찾을 수 없다는 에러가 나오게된다.
왜냐하면 WEB-INF라는 루트는 절대 외부에서 정할 수없는 디렉토리이기 때문이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

59 - View(list.jsp)에서 반복문 제거하기

View단에 아직 자바 코드가 남아있는데 그것을 제거하는 시간을 갖도록하자.
mvc로 만들었는데 아직까지 자바코드가 남아있다는것은 뭔지모르게 아직까지 스파게티 코드로 남아있다는 형태이기때문에 거부감이 느껴진다.
개념에 맞게 만들었다면 자바 코드블럭을 없애는게 맞다. 어떤 식으로 대체를 할것인가. 어쨌든 자바코드는 아니여야 한다.
태그라는것을 사용할것이다 .  원래 태그는 감싸고있는 컨텐트가무엇인지 설명하는녀석이다(what). 
		
foreach는 다르다. what보다는 행위에 해당한다. 액션을 가지고 있는 태그를 이용해서 코드블럭을 대신하려고 하는것이다. 

태그를 이용하기위해서 라이브러리를 다운받아야한다.
원래는 http://jstl.java.net 에서다운이 가능했는데 달라졌다. maven 저장소에서 다운이 가능하다.
https://mvnrepository.com/artifact/javax.servlet/jstl/1.2 

jar파일 다운받아야한다. jstl-1.2.jar를 다운받아서 WEB-INF 밑에 lib에다가 집어넣어야한다.
그러면 태그를 이용할수있다. 태그라이브러리를 쓰기위해서 이 태그를 꼭 써줘야한다.
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>



<%
List<Notice> list = (List<Notice>)request.getAttribute("list");
for(Notice n : list) {
	pageContext.setAttribute("n", n);
%>
					
를 하단의 코드로 교체할수 있다.

<c:forEach var="n" items="${list}"> 				//items: list저장소에서 꺼내서 꺼내서 가져오는것은 EL이 해주고 던져놓은값을 쓰는것을 var="n"이 쓸수있게해준다.
							// items속성에다가 저장소에 남겨져있는 내용을 뽑아서 items에 담을수 있다. 반복될때마다 하나씩 담아야하는데 그 그릇이 var이될것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

60 Tag 라이브러리와 JSTL

태그라이브러리를 쓰니까 mvc개념에 맞게 뷰단에서 자바코드를 없앴다.
과거에는 Standard Tag library가 존재하지않아서 각각의 library를 사용했었다.
JSTL에 대해서 더 자세히 알아보자

-JSTL 의 다섯가지의 범주
Core: 태그라이브러리가 필요로했던 가장 기본적인 제어의 행위를 담당하고 있는 태그 라이브러리 
Formating: 값을 출력할때 날짜, 숫자 화폐단위를 출력할때 그것을 포맷팅하는 방식이 필요할때 사용할수있는 기능
Functions:데이터를 EL을 이용해서 데이터를 추출한다 저장소에있는 데이터를 꺼내가지고 사용할때 가끔은 문자를 쪼개거나 소문자 대문자로 바꾸거나 문자열 조작이 필요할때 사용할수 있는 함수들을 묶어놓은 녀석
SQL: 쓰지않는게 바람직하다 mvc방법론이 나오기전에 뷰단에서 모든로직을 처리하는 방식이다. 코드의 구성이 깨짐
XML: 쓰지않는게 바람직하다 mvc방법론이 나오기전에 뷰단에서 모든로직을 처리하는 방식이다. 코드의 구성이 깨짐

세가지의 범주에대해서 사용할것이다.
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
접두사 c를 사용함

접두사를 사용하지않으면 Jasper가 처리하지않고 바로 출력할지도 모름
<c:forEach var="n" items=~~~> c

uri를 붙이는이유는 정의하고있는 태그가 식별이 가능하도록 식별자의 의미를 가지고있다. 태그를 식별할수있는 패키지명처럼쓰임
도메인네임이 꼭들어가는데 다른사람이 만든것이랑 충돌 안되도록

c는 uri=http://java.sun.com/jsp/jstl/core전부다 붙이기 힘드니까 c는  식별자(prefix)로써 uri를 의미한다.

예전에는 태그를 직접만들었지만 지금은 많이쓰는것들은 JSTL에 정의해놓았다 그래서 잘 사용하면된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

61 중간 요약 정리

지금까지 뭘배웠고 뭘나중에 배울것인지 알아보는 시간을 갖자.

서블릿: 자바 웹프로그램, 자바 웹서버 프로그램
우리가 배우는것은 자바 프로그램에다가 추가적으로 웹이라고하는것을 기반으로 프로그래밍할수있도록 배우는것이다.

콘솔프로그래밍은 system.out.println() 으로 콘솔에다가 출력

웹프로그래밍: 웹으로 입력과 출력을 다룬다. 	request 	입력설정,입력값읽기
		        			response	출력설정,출력스트림 StreamWriter로 읽어서 직접출력도가능

웹브라우저 기반으로 사용자에게 보내는데 문자열 몇개보내는게 아니라 브라우저에서 볼수있는 기본적인 문서 형태를 갖춰서 보내게되는경우가 있다. 
그래서 html태그를 출력해야하는데 불편하다. 

html태그를 출력하는 것을 도와주기위해서 웹문서 출력을 도와줄수있는 JSP라고하는 문서 기반으로 코드블럭만 삽입하는 방식으로 프로그램을 만들었다.

스파게티코드:처음에는 문서(jsp)기반의 코드블록이 오래갔었다. 2000년대 초반부터 많이 사용해왔다.
출력은 제스퍼가 서블릿코드로 만들어줘서 좋은것이다.

이게 마냥 좋은줄 알았는데 코드블럭이 너무 많아졌다. 산개되어있는 코드블럭을 관리하기 어려워진다는 생각을 했다.
좀 편하다 싶어서했더니 불편함이 느껴짐

mvc:
view단에 존재하는 코드블럭을 코드블럭이 아닌 코드블럭 EL: 뷰단에서 값을 출력해주는역할 ,JSTL: 뷰단에서 특정 출력영역을 제어해주는 역할이있다.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

62 forEach의 속성 사용하기

다뤄볼 목록들
<c:remove>
<c:choose>
<c:otherwise>
<c:forEach>
<c:url>
<c:set>
<c:if>
<c:when>
<c:forTokens>
<c:catch>

오늘 다룰내용은 forEach이다.
foreach는 컬렉션의 데이터를 꺼내서 반복을 시켜주고 하나씩 꺼낸녀석들을 다시 PageContext에 넣어서 ${n.id} 등등을 쓸수있게해준다.
foreach의 특성은 몇가지가 더있다. begin과 end가 한녀석이다. 사용하게되면 범위를 한정할수있다.
그렇다면 begin과 end에 사용된 숫자는 무엇을 기준으로 할까? 반복될때쓰는 index값과 비교하는것이다.

ex)	<c:forEach var="n" items="${list}" begin="1" end="3">		//1번째 인덱스 부터 3번쨰까지

그러면 반복할때 사용되는 인덱스가 있나? 	있다.
그러면 어떻게 사용하는가? foreach가 반복하면서 index같은것을 사용한다 이것이 상태를 나타내는 변수가 될텐데 인덱스와같은 상태값을 얻을수있다.
 varStatus="st" 		// varStatus안에 상태값을 알기위한 변수명만 설정하면 된다. 

st라는 이름으로 변수명을 설정했다. 그러면  ${st.index}  식으로 값을 알아낼수있다.


<c:forEach var="n" items="${list}" begin="1" end="3" varStatus="st" > 
<tr>
	<td>${st.index} / ${n.id}</td>
</tr>
</c:forEach>


st.current	반복할떄 사용되고있는 현재 객체 
st.index	0을 기반으로해서 index번째
st.count	반복되고있는 횟수
st.first	값이 첫번째값이면 True값을 아니면 False값을 반환한다.
st.last	마지막아이템인지 알아볼수있는녀석 마지막이면 True반환 아니면 False반환
st.begin	값이 설정한것에따라서 몇번째에서 시작할지 정할수있다.
st.end	값이 설정한것에따라서 몇번째에서 끝날지 정할수있다.
st.step	반복되는 인덱스의 증가치

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

63 JSTL :forEach문으로 Pager 번호 만들기

JSTL은 화면을 제어하기위한 태그라이브러리이다.
태그라이브러리를 이용해서 Pager를 구현해보자

페이저란? 1, 2, 3, 4, 5 를 눌러 글 다음,이전 글목록을 보는것

5개의 번호를 다섯개 복붙할까 반복문을 이용할까?
당연히 반복문을 이용한다.

<c:forEach var="i" begin="0" end="4">							// items라는 것없이 begin 과 end를 통해서 반복도 가능하다.
<li><a class="-text- orange bold" href="?p=${1+i}&t=&q=" >${1+i}</a></li>			// 하나씩 하나씩 증가되는값을 변수(var)=i 로 받아서 증가시킨다.
</c:forEach>

페이지가 1부터 5까지 잘나오는 것을 확인 할 수있다.
지금 현재로써는 1~5까지밖에 안나오지만 내가 클릭을 할수 있어서 7을 클릭했다고하면 번호는 어떻게 나와야할까?

번호는 6,7,8,9,10 으로 나와야한다. 클릭한것에 따라서 번호가 바뀌어서 나올수 있도록 코드를 고쳐야한다.

EL에라는 표기법을 함께사용하려고하면은 일반 지역변수 코드블럭지역변수가아니라 페이지컨텍스트에 저장되고있는 그런기법으로 사용해야한다.

//c:set 태그 : 임시변수 사용할수 있는 태그

<c:set var="page" value="${(param.p ==null)?1:param.p}"/>					// page라는변수 pram.p : 파라미터에서 전달되는 p라는 변수가 만약 비어있다면 1을 아니면 그 파라미터 값을 사용한다.		
<c:set var="startNum" value="${page- (page-1)%5}"/>						// startNum이라는 변수선언 그리고 값을 page- (page-1)%5가지고 페이지 컨텍스트에 저장된다.		
			
<ul class="-list- center">
	<c:forEach var="i" begin="0" end="4">
	<li><a class="-text- orange bold" href="?p=${startNum+i}&t=&q=" >${startNum+i}</a></li>
	</c:forEach>		

	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

64 JSTL : if 문으로 Pager 이전/다음 번호 만들기

다음페이지 버튼을 활성화 할것이다.

<span class="btn btn-next" onclick="alert('다음 페이지가 없습니다.');">다음</span>
이 코드를 상황에 맡게 나올수있도록 코드를 추가할 것이다.

<a href="?p=${startNum+5}&t=&q=" class="btn btn-next" >다음</a>
a 태그로 바꾸고 주소가 필요할텐데 위에서 사용하던것과 같이 p=${startNum+i} 를 써주고 0부터 시작해서 i가 제일큰값이 4인데 5를 더해주면 된다.

span과 link를 둘다보여주는 게아니라 하나만 보여주는 배타적인관계로 만들것이다.
if 문 또는 switch문이 가능한데 
if문으로 해보자

<c:set var="lastNum" value="23"/>							//마지막번호를 알아야하는데  레코드의 갯수가 몇개냐 데베의 갯수를 확인해야하는데 아직 임의적으로 데이터를 넣고 하는것을 아직 안배웠기때문에 값을 임의로 지정
<c:if test="${startNum+5<lastNum }">							//startnum(1,6,11,16...)+5이 lastNum보다 작으면 실행 
	<a href="?p=${startNum+5}&t=&q=" class="btn btn-next" >다음</a>
</c:if>
<c:if test="${startNum+5>=lastNum  }">
	<span class="btn btn-next" onclick="alert('다음 페이지가 없습니다.');">다음</span>
</c:if>




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

65 JSTL : forTokens로 첨부파일 목록 출력하기

forTokens라고하는 라이브러리를다뤄보면서 첨부파일 목록을 컬럼하나에 쉼표로 구분해서 넣을텐데 뷰단에서 어떻게출력할것인지 알아보자
데이터베이스에서 데이터 컬럼을 보자 FIles 라는 컬럼이있다. 파일목록을 가지고있는컬럼이다.

test.zip,aa.gif,bb.png를 파일컬럼에다가 넣었다. 이제 모든것을 하이퍼링크로 감싸서 표현해야하는데 안된다!'

-detail.jsp

<tr>
	<th>첨부파일</th>
	<td colspan="3">${n.files}</td>					//files라고하는 녀석이 단일한 데이터가아니라 쉼표로구분된 목록이다.
</tr>
		 			

그래서
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>			//코드 상단에 JSTL문을 추가해주고


<td colspan="3">
<c:forTokens var="fileName" items="${n.files}" delims=",">			//delims: 구분자이다. 문자열을 기준으로 끊을수있다. "," 했을때 , 기준으로 끊는다.
	<a href ="">${fileName }</a>					//끊은 녀석을 하나씩 반복해서 꺼내보기위해서는 변수가 필요하다 그래서 var="fileName" 라고 씀
</c:forTokens>
</td>

문자와 문자사이의 구분자(뷰단에서 )필요하다

<td colspan="3" style="text-align:left; text-indent:10px;">
<c:forTokens var="fileName" items="${n.files}" delims="," varStatus="st">		//varStatus는 상태값을 확인하기위해썼다.
	<a href ="">${fileName }</a>
	<c:if test="${!st.last}">						//상태값이 마지막인자가 아니라면 /를 출력하겠다.
	/
	</c:if>
</c:forTokens>
</td>


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
