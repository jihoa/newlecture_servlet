02 웹서버 프로그램이란

그렇다면 웹서버 프로그램은 무엇인지 이해하는것이 중요하다

예전에는 서버프로그램이라는것이 없었다.
콘솔,윈도우 프로그램 이정도 차이

사용자가 컴퓨터를 바로 사용하는것이었다.

하지만 
본점과 원산지가 있는데
(클라이언트) (서버)
본점에서 원산지에 있는 데이터를 보고싶어서 나누게 되었다.
옛날에는 서버 클라이언트 동일한언어로 만들었는데 불편한점이 생김
원래는 업데이트시 설치 재설치를 했는고 데이터전송 구현의 어려움이 부담되어서 웹을 사용하기 시작하였다.

웹프로그래밍이란 서버 클라이언트 프로그램이 아니라
웹에 서버클라이언트를 얹음

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

03 웹서버 프로그램과 Servlet

WEB vs WAS
WEB은 WEB서버에 문서만 있는것이다
WAS 사용자가 요구하는 내용이 동적이면 실행할수있는 DB와연동가능한것이 WAS (서비스를 할수있는 녀석이 추가적으로 설치되어있어야한다.)

WAS 구성요소
1.Server app = 동적으로 요구하는 내용을 문서로 만들어줄수있는것
2. WAS = 코드를 찾아서 실행해줄수 있는 환경 Tomcat

웹문서를 제공해주는 녀석 = webserver

Servlet은?(서버 어플리케이션 조각)
사용자가 요청하는 내용 GET:list/reg/edit/del

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

04 톰캣9 설치하기(환경설정)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

05 톰캣9 설치하기- 웹문서 추가해보기
- 웹서버는 예약되어있는 특정폴더가있고 그폴더에다가 문서를 저장하고 다른 원격에있는 컴퓨터 브라우저에서 리소스 이름을 입력하면 그 문서를 보여준다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

06 톰캣9 설치하기 Context 사이트 추가하기

Context란?(가상 경로)
사이트가 커지다보면 파일 디렉토리가 많아질것이다.
물리적으로는 두개의 사이트인데 실제는 하나의 사이트로 돌아가게 하는것이다.
규모가 클경우에는 컨텍스트를 나눠서 작업하는 경우도있다.

      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
	<Context path="it" docBase="C:\tools\apache-tomcat-9.0.41\webapps\ITWeb" previledged="true" />	//이 줄을 추가해준다.
추가하게되면 localhost:8080/it/ 로 접근이 가능하다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

07 처음으로 서블릿 프로그램 만들어보기
-왜 웹서버 응용 프로그램을 Servlet이라고 명칭할까?

Servlet은 기능에따라 나눠져있다.
원래 Javas는 main() 함수를 중심으로 만든다.
service()라는 함수로 만든다.

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request
			, HttpServletResponse response)
			throws IOException, ServletException
	{
		System.out.println("hello Servlet");	//서버 콘솔에 출력된
	}
}
이런식으로 작성한 후에 cmd 에서 해당경로 에서 javac -cp <servlet-api.jar 경로> Nana.java 를 실행하면 에러없이 돌아가면완료된것
$javac -cp C:\tools\apache-tomcat-9.0.41\lib\servlet-api.jar Nana.java

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

08 서블릿 객체 생성과 실행방법
지난시간에 nana파일을 컴파일해서 클래스파일로만들었음

둬야하는 위치
/
WEB-INF/				// 루트 아래에 WEB-INF 가 없으면 만들어야한다.
	web.xml
	classes/			//그아래에 classes 밑에다가 넣어야한다.
		Nana.class

넣고나서 http://newlecture.com/web-inf/classes/Nana.class
이렇게 하면 절대로 되지 않는다. 이걸 사용자가 요청하는것도 문제고 요청한다고 주는것도 문제다.
WEB-INF는 서버쪽에서만 사용할수있다. 클라이언트는 요청할수가없다.(비공개 영역)

사용자가 요청하는 방법
web.xml에서 URL 과 매핑된 Servlet 코드를 찾아서 실행 
(약속된 매핑방식으로 요청)

-web.xml

<servlet>
	<servlet-name>na</servlet-name>
	<servlet-class>Nana</servlet-class>	//2. 해당하는 클래스를 실행하겠다.
</servlet>
<servlet-mapping>
	<servlet-name>na</servlet-name>
	<url-pattern>/hello</url-pattern>	//1.hello라고 요청했을때
</servlet-mapping>

이렇게 등록을 해놓으면 사용자가 http://localhost/hello 를 입력했을때 hello라고 요청하고 요청에 해당하는 클래스를 실행해주겠다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

09 서블릿(Servlet) 문자열 출력 

자바 웹프로그래밍 
웹이 담당하고있는 부분은 UI ,UI는 콘솔UI  윈도우UI 두개로 나뉨


import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request					//HttpServletRequest 입력도구 
			,HttpServletResponse response)				//HttpServletResponse 출력도구	
			throws IOException, ServletException
	{
	 OutputStream os = response.getOutputStream();				//출력이나 입력을 할때는 Stream 을 쓰는것이 기본이다.
	 PrintStream out = new PrintStream(os,true);					//byte나 바이너리로 출력할것이 아니기때문에 PrintStream 객체를 사용한다. 쉽게 출력가능 true: flush이다. 글자하나썼다고해서 보내는게아니고 버퍼가 8KB채워야보내는데 그냥 보내라
	 out.println("Hello Servlet!!");
	}
}

뭐하나 수정하면 절차가 불편하다. 그래서 이클립스를 사용하는것이다.

문자열 출력이 기본이라면 이렇게 복잡하게 안해도된다 파일을 받아서 바이너리로 출력한다면 위와같이하지만
문자열을 출력할때는 PrintStream을쓰고 PrintStream을 기본적으로 제공해주는 Getter가 있다.

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request					//HttpServletRequest 입력도구 
			,HttpServletResponse response)				//HttpServletResponse 출력도구	
			throws IOException, ServletException
	{

	 PrintWriter = response.getWriter();							//자바에서는 Stream Writer두가지있는데 Writer는 다국어를 지원하기 때문에 Writer를 사용한다.
	 out.println("Hello Servlet!!");
	}
}
 
우리는 앞으로 간단하게 Writer를 얻어서 사용할것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10 웹 개발을 위한 이클립스 IDE준비하기
도구를 통합시켜놓고 쉽게 개발할수있는 환경이있다. 일반적으로 자바로 개발할때는 이클립스 인터프라이즈 버전을 사용한다.

코드를 만들게 되면

코드수정=>컴파일=>배포=>톰캣 서버 재시작 => 브라우저로 요청
이과정을 거치는데 이클립스를 사용하면 Ctrl + F11을 누르면 해결된다.

프로젝트 생성시 New=> Dynamic Web Project
이렇게 하면 서블릿 프로젝트가 만들어지는것이 아니라 서블릿코드를 만들고 실행하기위한 환경이 만들어지는것이다. 
우리가 톰캣을 설치하기는 해씨만 was는 톰캣만 있는것이아니다.
그래서 톰캣 9.0 선택하고 톰캣의 위치 홈디렉토리를 찾아주면 끝난다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11 이클립스를 이용한 서블릿 프로그래밍

ctrl+f11 을 누르게되면 톰캣을 설정해놨는데 그것의 복사본이 생기는 것이다.
창이뜨는것은 서버설정을 하겠다라는 뜻.
실행이되었을때 이클립스 내에서 브라우저가 실행되는데 그것을 크롬이나 다른 브라우저로 설정할수도 있다.
window=> Web Browser 에서 선택하면된다.

html의 경우

프로젝트 생성후에 홈디렉토리는 WebContent가 된다
홈디렉토리에있는 문서를 그냥 요청한것이다. 컨텍스트 이름이 루트에 해당하는 프로젝트는 컨텍스트 명을 갖는것이 좋은것이 아니다.
기본프로젝트이기때문에 컨텍스트명을 프로젝트명으로 쓰지않을것이다.

컨텍스트명 변경 방법
프로젝트 오른쪽클릭=> properties=>Web Project Settings

서블릿의 경우
패키지를 만들기위해서 Java Resources 로 간다 src라는곳에다가 만든다 기존에는 패키지명없이 만들었는데
Package명은 com.newlecture.web 		// newlecture에서만드는 웹페이지
로 만들자

-Nana.java

package com.newlecture.web;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		PrintWriter out = resp.getWriter();
		out.println("hello!");
	}
}

다 작성하고나서 실행을하려면 매핑이 되어있어야하는데 매핑하기위해서는 web.xml에다가 매핑을했었다.
WEB_INF안에 web.xml이 없으면 복사해온다.

-web.xml
<servlet>
	<servlet-name>na</servlet-name>
	<servlet-class>com.newlecture.web.Nana</servlet-class>		//원래는 <servlet-class>Nana</servlet-class> 클래스명만 적었지만 패키지명도있으면 적어야한다.
</servlet>

<servlet-mapping>
	<servlet-name>na</servlet-name>
	<url-pattern>/hello</url-pattern>
</servlet-mapping>

이렇게 까지 바꿔주면 전에는 Nana.java코드를 바꿔주었을때 실행하고 컴파일하고 배포하는 과정을 거쳐야하지만 ctrl+F11을 눌러주면 해결된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12 어노테이션을 이용한 URL 매핑

일단 어노테이션이란?
ex)
@WebServlet("/hello")		//클래스나 메소드에 붙어져있는 주석이다.
				// 원래 주석은 컴파일러에 의해서 사라지지만 어노테이션은 컴파일러에 의해서 사라지지 않는다. 메타데이터라고 부르기도한다.


web.xml에다가 서블릿과 URL을 매핑했는데 어노테이션을 이용해서 서블릿과 URL을 매핑하는 법을 알아보자
어노테이션을 이용해서 실행하는데 영향을 줄수있다. 어노테이션으로 매핑정보를 실을수도 있다,
매핑정보를 남길수도있다. web.xml 안가도 된다.

web.xml에서

서블릿 2. 대에서는 web.xml에서만 매핑이가능했다 하지만
서블릿 3. 대에서는

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="false">		// 매핑정보를 설정할때 true로 하게되면 모든 메타데이터(설정)는 web.xml에 있다.
					// false로 할시에 여기외에도 어노테이션설정한게 있으니 찾아봐라 라는뜻
					//true-> false로 바꿔주기

web.xml 설정만 바꾸고 실행을 하게되면 안된다.

다시 서블릿 파일인 Nana.java로 돌아가서

@WebServlet("/hi")를 import문 밑에다가 추가해준다.
성공

Web.xml도 가능하고 어노테이션도 가능한데 어노테이션이 더 쉽다. 그리고 분업을할때도 훨씬 깔금하게 작업이 가능하다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

13 서블릿 출력 형식을 지정해야 하는 이유

서블릿을 출력할떄 출력을 어떻게하고 클라이언트는 어떻게 이해할까?

public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		PrintWriter out = resp.getWriter();
			for(int i=0; i<100; i++)
			out.println((i+1)+":Hello Servlet!!");
	}
}
이 코드를 실행해보자
크롬에서는 prinln이 적용되었고 익스플로러 에서는 print로 적용이되었다.
익스플로러 처럼 떠야하는것이 정상이다 왜냐하면 웹문서로 인식했기때문에 <br> 태그를 통해서만 내려쓰기가 되어야지 정상이다.

그래서 <br>을 추가해서 out.println((i+1)+":Hello Servlet!!<br >"); 돌려보자
익스플로러는 br태그를 정확하게 인식하였지만 크롬에서는 br문자가 그대로 출력이 되었다.
왜 이러냐면 브라우저가 자의적인 해석을 했기 때문이다.
익스플로러는 html로 해석하고
크롬은 text로 해석한다.
어떤 내용을 클라이언트에게 보낼때는 형식을 정해주는게 중요하다.

다음시간에는 문서를 보낼때 어떤형식으로 보낼때 어떻게 보낼지 한글을 쓰면 깨지는데 안깨지게 하는것을 알아볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

14  한글과 콘텐츠 형식 출력하기

서블릿을통해서 문자를 보내봤는데 사용자가 컨텐츠의 형식을 자의적으로 해석했다. 하지만 원래는 정해주고 보내주는것이맞다.

package com.newlecture.web;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/hi")
public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		resp.setCharacterEncoding("UTF-8");		//인코딩방식을 UTF 로 정하자! 이걸안하면 ??으로 뜸
		resp.setContentType("text/html; charset=UTF-8");	//받은것을 어떻게 해석할까 콘텐츠타입은 무엇인지 정의하는 문구 UTF-8로보냈고 charset=UTF-8이기때문에 UTF-8로 읽자 더불어서 이녀석이 html문서이다.
		PrintWriter out = resp.getWriter();
		for(int i=0; i<100; i++)
			out.println((i+1)+":안녕 <br />");
		
	}
}



하지만 이렇게 했음에도 불구하고 뚬궶 이런식으로뜬다.
?? 나오는것은 아예 잘못전달 뚬궶은 인코딩을 바꿔주면 해결되는것
크롬 개발자 도구에서 응답 헤더에 콘텐츠가 UTF-8 로 읽어져야한다고 심어줘야한다. 이렇게하지않으면 글자가 깨진다.
서버에서 심어주도록하자
resp.setContentType("text/html; charset=UTF-8"); 을작성해주고나면 한글도 잘표시된다.
그리고 다시 크롬 개발자 도구에 가보면 Content-Type: text/html;charset=UTF-8이 응답헤더에 있는것을 확인할수 있다. 


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

15 GET 요청과 쿼리스트링

지난시간에 한것은 출력방법이다. 어떻게 출력할것인가? 주의사항 인코딩방식 한글깨지는것 등등 배웠다.
이번시간은 사용자가 입력한거 처리하는것 사용자의 입력이라고 하는 것은 결국은 나한테무언가를 요청하는것이다
입력과 요청은 뗄래야 뗄수가없다. 요청할때 전달하는값을 어떻게 받을것인가?

사용자의 요청의 기본은 GET 요청이다.

기본적으로 웹이라는것은 사용자가 무언가를 요청하게 되어있고 서버가 그에 준하는 응답을 하게되어있다.
무엇을 달라고하는 요청에는 옵션이 있을 수가 있다.


 http://localhost/hello   => GET
 http://localhost/hello?cnt=3   => GET		//쿼리 스트링: ?를 쓰고 키값을 전달할수있다. 
					//추가적으로 옵션을 읽어서 그옵션에 맞는 문서를 줘야겠다 해서 쓴다.
					//hello를 3번만 반복하는 hello문서를 반복한다.

package com.newlecture.web;

@WebServlet("/hi")
public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {			//서블릿이라고 하는 service에서 보면 입력인 req, 와 출력인 resp가 있다.
		
		resp.setCharacterEncoding("UTF-8");
		resp.setContentType("text/html; charset=UTF-8");
		
		PrintWriter out = resp.getWriter();
		
		int cnt = Integer.parseInt(req.getParameter("cnt"));	//req도구에 getParameter가있다. 사용자가 전달할때 쿼리값을 심어서 전달하면 키워드를 읽을 수가있다. cnt라는 값을 읽는데 문자열로전달되기때문에 Integer.parseInt로 정수로 바꿔줌
		
		for(int i=0; i<cnt; i++)
			out.println((i+1)+":안녕 Servlet<br />");
		
	}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

16 기본값 사용하기

입력값을 처리하는 방법을 배웠는데 입력값이 없었으면 오류가 발생했다. 사용자가 입력안해도 오류가 안나게 하겠다 하려면 기본적으로 사용할 값이 있어야한다.
http//..//hello?cnt=20		//이게 기본적인 쿼리 스트링

http//..//hello?cnt=3		// "3"
http//..//hello?cnt=			// "" (빈문자열)
http//..//hello?			// null
http//..//hello			// null

String temp = request.getParameter("cnt");		// temp에 값을 받아놓음
int cnt= 0;					// 기본값으로 등록해놓음
if(temp != null && !temp.equals(""))					// temp가 null이 아니고 tmep값이("")이아니면 왜냐하면 빈문자열이오면 인트형으로 못바꾸기때문 cnt 를 temp값으로 바꿈
	cnt = Integer.parseInt(temp);
for(int i=0; i<cnt; i++)				
	out.println((i+1)+":안녕 servlet!!<br/>");

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

17 사용자 입력을 통한 GET 요청

Get요청할때 값을 사용자가 입력할수있게 하는법을 배울것이다.
이렇게 만들어주는데
<body>
	<div>
		<form action="hi">		//http://.../hi?cnt=3   입력된값이있으면 cnt= 입력된값으로 쿼리스트링을 만들어줌
			<div>
				<label>"안녕하세요"를 몇번 듣고 싶으세요?</label>
			</div>
			<div>
				<input type="text" name="cnt"/>
				<input type="submit" value="출력"/>
			</div>
		</form>
	</div>
</body>


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

18 입력할 내용이 많은 경우는 POST 요청

Get 요청할때 queryString을 이용해서 값을 전달할수 있다. 그리고 그것을 서버쪽을 담당하는 우리는 그것을 서버에 받아서 값 이용가능
입력값이 많을경우에는 예를들어

양파는 빼주시고요
고기는 중간정도로 익혀주시고
케찹은 많이 주시고
치즈는 반만 주시고
상추는 양배추로 바꿔주시고 등등 많약 입력값이 많으면? 받는쪽에서는 기억하기 힘들다.


그래서 과정을 만들어서

1.햄버거를 위한 주문서를 주세요 =>Get 요청을 한다.
 
2.주문서를 작성해서(양파=빼고&고기=중간&치즈=반만$상추=/..) =>Post요청을 보낸다.

3.요청을 처리해서 햄버거를 준다.

<body>
	<div>
		<form action="notice-reg">
			<div>
				<label>제목: </label>
				<input type="text" name="title">
			</div>
			<div>
				<label>내용: </label>
				<textarea name="content"></textarea>
			</div>
			<div>
				<input type="submit" value="등록"/>
			</div>
		</form>
	</div>
</body>

요청을 하게된다면 쿼리스트링으로 URL으로 나타나게된다.
이렇게되면 문제가 두가지있다.
1.URL에 붙어가는경우에 길이 제한이있다.
2. 달라고하는것이 문서라면 문서의 옵션값이 쿼리스트링이다. 장문의 내용을 보내는것은 올바르지않다.


<form action="notice-reg"> 	//아무것도 옵션을 정하지않으면 쿼리스트링으로 전달한다.
<form action="notice-reg" method="post"> 	//형식으로 하게 된다면 POST방식으로 전달하게된다면 이것은 사용자가 입력받은것을 제출하는것이다. 입력받은것이 많기때문에 URL로 제출하지않는다.
					
크롬 개발자도구에서 네트워크로 들어가서 어떻게 전달되었는지 확인해보자.
Form Data 항목에 들어가보면
title=aaaa&content=bbbb
이렇게 요청바디로 전달됐다. 길이 제한도 없다. 큰데이터를 보낼수있다.

그렇다면 한글을 써서 보내보자! 한글이 깨졌다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

19 한글 입력 문제

한글 POST 할때 깨지는 문제가 있었다 어떤게 문제고 어떻게 해결하는지 알아보자
저희가 한글을 출력하는데에 문제가 없었다.

이번문제는 전달(POST)하다가 문제가 발생했을것이다.

UTF-8은 멀티바이트 문자이다. 문자하나당 숫자하나가 연관되어있다. 한글은 2Byte 영문자 1Byte
톰캣의 기본적인 인코딩 방식은 ISO-8859-1 방식이어서 에러가 난것이다!

UTF-8 로 바꾸는 방법은 두가지가있다!

1.server.xml 설정을 바꾸는 방법
 <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort=8443" URIEncoding="UTF-8" />
하지만 이방법은 잘 사용되지 않는 방법이다. 왜냐면 톰캣서버에는 여러개의 서비스를 돌릴수 있기 때문이다. 다른 서비스에 영향을 줄수 있기 때문이다.

2.Servlet 설정을 바꾸는 방법
request.setCharacterEncoding("UTF-8");

다음시간에는 한글설정을 필터라는 방식으로 설정하는 법을 배울것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

20 서블릿 필터(Servlet Filter)

WAS(톰캣)가 사용자로부터 요청이 들어오면 적정한 소프트웨어를 실행해서 결과를 돌려주도록 되어있다.
그 소프트웨어를 서블릿이라고 하는데 
서블릿을 실행하게되면 메모리상에 존재하게될텐데 그 공간을 Servlet Cotainer라고하고 WAS는 서블릿을 실행시켜서 결과를 돌려주게 되고 그리고 사용되지않으면 컨테이너에서 삭제

서블릿만 주구장창 만들었는데 또 만들수있는 오브젝트는 필터이다.
사용자로 부터 입력을 받을때는  request.setCharacterEncoding("UTF-8"); 설정을 해야한다. 그렇다면 톰캣이 사용하고있는 방식을 UTF8로바꾸면 어떨까? 들어오는 입력에대한 입력을 UTF8로바꾸면된다
하지만 그것은 부담스럽다 왜냐면 다른 서비스도 제공하기때문이다. 그러니까 우리꺼에만 영향을 주고싶은데 그렇다고해서 서블릿마다 이런작업하긴 불편하다. 그래서 중간에 위치할수있는 소프트웨어가 있다. 
요청이 들어오면 요청을 서블릿을 실행하는 쪽으로 가는데 이 소프트웨어는 가로채기가 가능하다. 수문장역할을 하는것이다 이 수문장녀석은 서블릿을 실행할지 말지도 결정이 가능하다. 모든 서블릿이 가지고있는 기본설정을
어차피 거쳐가는것이니까 다 영향을 주게할수도있다.
먼저 실행되는것이 기본적이지만 response에도 영향을 주게하는것도 가능하다. 이녀석을 Filter라고 부른다.

Filter를 만들어보자 원래있는 프로젝트에다가 만들지말고 새로운 프로젝트
com.newlecture.web.filter 프로젝트를 생성하고
그아래에 CharacterEncodingFilter를 만들자 Add를 눌러서 인터페이스를 추가하자 filter로 검색해서 javax.servlet.Filter 를 추가하자

생성하고 난 이후에 		System.out.println("hello filter"); 을 설정해주자
이렇게 필터를 생성하고 설정을 하면 어떠한 요청이 와도 필터가 자동으로 동작하게 된다. 요청이 올때마다 동작이되긴하지만 톰캣이 실행될때도 동작이된다.

web.xml 에서 필터를 설정하자. 
필터 설정할때 두가지가있다 서블릿처럼 xml도되고 어노테이션도된다 서블릿먼저하고 어노테이션으로 바꿔보자

-web.xml

<filter>										//현재 내가 어떤 클래스를 쓸까 와 어떤이름쓸지를 등록
	<filter-name>characterEncodingFilter</filter-name>
	<filter-class>com.newlecture.web.filter.CharacterEncodingFilter</filter-class>		//필터 패키지 + 필터 클래스명
</filter>
<filter-mapping>									//필터에대해서 어떤 매핑을 쓸까와 이름은 뭘로할지
	<filter-name>characterEncodingFilter</filter-name>
	<url-pattern>/*</url-pattern>						//어떤 URL을 사용할지를 정하는데 /*는 모든 URL
</filter-mapping>


noitce.reg가 정상적으로 실행되었는데 아무것도 안나온다. 왜 안나올까?  필터가 실행되었는데 서블릿실행으로 갈지말지는 필터가 결정하기 떄문이다.
필터라는 녀석을 두고

-CharacterEncodingFilter.java

public class CharacterEncodingFilter implements Filter {

	@Override
	public void doFilter(ServletRequest request
			, ServletResponse response
			, FilterChain chain)					// 이 흐름을 다음녀석에게 전달 해줄까 말까는 얘가 결정한다.
			throws IOException, ServletException {
		System.out.println("before filter");				//요청이오면 이게 실행
		req.setCharacterEncoding("UTF-8");				//모든 서블릿 실행전에 인코딩 작업할것이기 떄문에 여기다가 넣어준다.
		chain.doFilter(request, response);				//다음 필터 혹은 서블릿으로 실행되게 한다. 	
		System.out.println("after filter");				//다음 필터나 서블릿이 실행되고 나서 실행된다.

	}

}

어노테이션으로 하는 방법을 알아보자

-CharacterEncodingFilter.java

import java.io.IOException;

@WebFilter("/*")								// 이 문구만 사용해주면된다. 여러가지 불필요한 작업을 없앨수있다.

public class CharacterEncodingFilter implements Filter {


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

21 학습과제 (사용자 입력을 통한 계산 요청)

완료


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

22 과제풀이(사용자 입력을 통한 계산 요청)

계산을 요청하게되면 값이전달 전달되는값은 문자열 형태로간다.
프로그래밍은 보고따라하는게 아니라 직접해보는게 실력이 늘어난다.

com.newlecture.web 밑에 add 라는 자바파일을 추가하려고 한다. 
하지만 원래는 class를 클릭해서 클래스를 생성했지만, 오늘은 Servlet을 클릭할것이다. Servlet은 이클립스에서 제공하는 폼이고,
이것을 선택하게 되면 서블릿 클래스를 생성할수있다.

과정중에 URL 매핑도 수정할수있다. Add라는 파일명이지만 매핑은 add로 선택
그리고 다음을 눌러서 Inherited abstract methods(상속 추상 메소드)에 service만 선택 그리고 Finish

자동으로 생성해주는 코드다 보니 군더더기가 많이 있다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

23 여러 개의 Submit 버튼 사용하기

지난시간에 했던것은 버튼하나로 덧셈만되는것이었지만 이번시간에 할것은 버튼을 두개 만들어서 덧셈 뺄셈을 하게 할것이다.
덧셈과 뺄셈 어떻게 식별할까? 서블릿이 식별할줄알아야한다. 

add.html 을 복사해서 calc.html을 새로 만들자
com.newlecture.web 밑에 Add.java도 복사해서 calc.java를 만들어준다. 
복붙을 하게되면 문제가 되는것은 바꿀것은 바꿔줘야한다는것이다.
어노테이션 @WebServlet("/add") 를 @WebServlet("/calc")로 바꾸어준다.

calc.html 에서 form action도 calc로 바꾸어주자.
<input type="submit" value="덧셈"/>
<input type="submit" value="뺄셈"/>			//복붙해서 추가해주자

그리고 서버를 실행시켜서 확인을 해보게 되면 덧셈버튼 뺄셈버튼 둘다 동작이 똑같음을 알수있다.
우리는 어떻게 두개가 차이점을 알기위해서 어떻게 값이전달되는지 확인해야한다. 개발자도구로 가자
네트워크라는 탭을 선택하고 그래프에 아무것도 없어야한다. (있다면 clear를 누르자)

그리고 덧셈버튼을 누르면 서버에게 전달되는 POST 데이터를 구경할수있다.
누르면 요청했던 문서에대한내용이나오는데 calc를 클릭해보자

Form Data가 있는데 확인해보자
x=2
y=3 
(이런식으로 나와있다.)

view source로 보면 정리안된상태 x=2&y=3이라고 나온다. 값만 전달된다. 서버쪽에서는 어떤 버튼이 눌렸는지 알수가없다.
알수있게하는 방법이있다.

calc.html 로와서 버튼에 name값을 넣어주자
<input type="submit" name="operator" value="덧셈"/>
<input type="submit" name="operator" value="뺄셈"/>

이렇게 name에 같은 이름인 operator을 줬는데 왜냐면 다른입력 컨트롤과 달리 operator는 두개를 다 클릭할일이없다.
input이라는 녀석은 중요한것은 name값이 있으면 전달된다. 하지만 type="submit"은 선택된 놈만 전달된다. name 없으면 전달x 
(덧셈 클릭하면 덧셈 전달 뺄셈전달하면 뺄셈 전달)

코드를 수정하고 서버를 실행한다음 다시 개발자도구에서 확인해보자
Form data에 
x=2
y=3 
operator = 덧셈
(이런식으로 바뀐것을 확인할수있다.)

view source를 누르게되면
x=3&y=2&operator=%EB%8D%A7%EC%85%88 		//이런식으로 표현되는데 한글을 url방식으로 전달되기는 무리가있기에 인코딩된것

서버쪽에서는 operator의 값을 식별할수 있게 되었다. 

String op = request.getParameter("operator");			//operator라는 파라미터를 가져온다.
		
		int x= 0;
		int y= 0;
		int result=0;				//result 초기값은 0으로 선언
		
		if(!x_.equals("")) x= Integer.parseInt(x_);
		if(!y_.equals("")) y= Integer.parseInt(y_);
		
		if(op.equals("덧셈"))			//operator 값인 op가 덧셈이면 덧셈수행
			result = x+y;
		else					//그외(뺄샘이면) 뺄셈을 수행
			result = x-y;


버튼이 두개가있어도 서버에서 선택적으로 결과를 처리할수 있다는것을 배웠다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

25 상태 유지를 필요로 하는 경우와 구현의 어려움

웹개발하다보면 상태유지에대한 필요성과 방법이 중요하다. 웹이라는 녀석은 어플리케이션이 조각나있다. 서블릿 역시
전역변수라는 개념이 필요한데 없다. 전역변수처럼 값을 유지해줘야하는데 어떻게 해야할까>

지역변수값을 받아서 어디다가 저장해줘야한다. 서블릿들간에 값을공유할수있는게없다.
그래서 세가지를 사용한다. 서블릿들이 살았다 죽었다를 반복하면서 값이 사라지지않고 담을수있는 세가지이다.

application
session
cookie

일단 세가지의 도구를 사용하는 법을 배워볼것이다.

WebContent 아래에 있는 calc를 복사해서 calc2를 만들어보자

-Calc2.html-

<body>
	<form action="calc2" method="post">				// action값을 요청하는 컴포넌트값인 calc2로 바꿔주자
		<div>
			<label>입력 : </label>
			<input type="text" name="v"/> 			//입력박스가 두개가 아니고 하나로 만들어서 하나씩 하나씩 전달하게하자
		</div>
		<div>
			<input type="submit" name="operator" value="+"/>
			<input type="submit" name="operator" value="-"/>
			<input type="submit" name="operator" value="="/>
		</div>
		<div>
			결과 : 0
		</div>
	
	</form>
</body>

 실행을해보게 되면 좀 더 계산기 같은 형태로 바뀌었다. 2를 입력을하고 +를 누르게 된다면 그러면 2라는숫자와 덧셈이라는 오퍼레이터가 전달될것이다.
서버쪽에서는 무조건 저장해야하고 페이지를 다시 돌려줘야한다. 그리고 3을 누르고 = 를 누르면 어디서 꺼내가지고 값과 연산자에 의해서 계산을해서 돌려줘야한다.

일단 프론트는 완성했으니까 서버쪽 페이지는 어떻게 해야하냐면

Calc.java를 복사해서 Calc2.java로 복사하자

Calc2로 만들었으니 어노테이션도 바꿔주자

@WebServlet("/calc")  => @WebServlet("/calc2")

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

26 Application 객체와 그것을 사용한 상태 값 저장

상태를 저장하기위해서 다뤘던정보를 잠깐 저장하기위해서 Application 객체를 사용하는 방법을 알아보자

ex) 1번 서블릿을 여러분이 요청하게되면 1번 서블릿이 메모리에서 처리하면 1번서블릿이 메모리에서 사라진다. 
그래서 서블릿이라는 녀석을 사용할때 그들간에 그자신간의 데이터를 저장할수있는 메모리 저장소를 사용하는것이 필요한데 그것이 서블릿 Context이다. 
어플리케이션을 만들다보면 API중에서 Context 라는 이름을 가진아이들이 많다. Context라는 것은 문맥,책갈피 라는 사전적 의미를 가지고있다.
책갈피는 책을 이어갈수있도록 하는 상태값을 표시하는 역할을 한다. 책을 읽을때 다음에 다시 읽을수있도록 해주는 공간이다.

서블릿 컨텍스트:A라는 서블릿이 만든 결과를 저장하면 B라는 서블릿이 그 결과를 이어서 새로운 결과를 만들 수 있도록 하는 상태 저장공간

웹어플리케이션에서는 어플리케이션 저장소라고 부르기도 한다.

서버쪽에서 사용자 전달한 값이 있을텐데 그값을 저장할수있느냐, 다음 요청에서 그값을 꺼내볼수있느냐 그것이 우리가 알아볼내용이다.

@WebServlet("/calc2")
public class Calc2 extends HttpServlet {
	
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		ServletContext application =request.getServletContext();						//이 값을 저장해야하는데 어디다 저장해야하는가? request에보면 ServletContext()가있다. 이것이 어플리케이션 저장소이다 application이라는 변수에다가 getservletCOntext()를저장하자
		response.setCharacterEncoding("UTF-8");
		response.setContentType("text/html; charset=UTF-8");
		
		String v_ = request.getParameter("v");											//사용자가 전달하는 값은 하나만 전달한다.
		String op = request.getParameter("operator"); 									//그리고 오퍼레이터를 같이 전달한다.
		
		int v= 0;																		// 기본값이 필요할까도 생각을 해봐야한다. 전달하는 내용이 값이없을때 기본값으로 받아야하나? 값입력x시 0으로 처리하기위해 v=0 기본값세팅
		if(!v_.equals("")) v= Integer.parseInt(v_);
		
		//계산
		if(op.equals("=")) {															//왜 if문에 =(equal)로했냐면 덧셈과 뺄셈은 하는일이 같다. 하지만 =는 계산하는것이다. 
																						//아래에서 값을 읽어와야한다. 하나는 앞에서 저장했던내용이고 하나는 지금가져온내용으로 두가지를 읽어야한다.
			
			int x = (Integer)application.getAttribute("value");							//앞에서 저장한값을 어플리케이션저장소에서 꺼내와야하는데 application.getAttribute("담을떄사용했던 값")메소드를 사용한다. 그리고 (Integer)을 안했을 떄 빨간줄이 뜨는것은 Object로 값을 반환하기 때문이다.
			int y = v;																	//지금사용자가 저장한값
			String operator= (String)application.getAttribute("op");					//그래서 그 밸류값과 앞에서 저장했던값을 꺼내서 덧셈을 할지 뺄셈을 할지는 사용자가 저장했던 operator값을 꺼내서 봐야한다. 어플리케이션 저장소에서 읽어오자
			int result=0;
			
			if(operator.equals("+"))			
				result = x+y;
			else
				result = x-y;
			response.getWriter().printf("result is %d", result);
		
		
		}
		// 값을 저장
		else {
			application.setAttribute("value", v);										//application에다가 두가지를 저장하자 v(값), op(연산자) setAttribute에다가 저장한다 어떻게 저장하냐면 map Collection처럼 key 와 value를 넣어준다.
			application.setAttribute("op",op);  						 				//오퍼레이터도 같은 방식으로 저장해주기위해서 key와 value를 저장해주자 이것들을 두고두고 쓸수있다.																						//전달된내용이 op이 뭐냐인가에 따라서 저장해야할수도있고 계산이 될수도있다.	
		}		
	}
}

다 되는데 왜 화면이 하얗게 질리는지 그것이 아쉽지만 잘 동작하긴한다. 다음시간에 왜그런지 알아보자 중요한것은 application 저장소를 활용할수있는지가 중요하다.
다음시간에 세션과 쿠키를 이용해서 저장소를 사용하기위한 적절한 시기와 장소를 알아보는것으로 하자.

SetAttribute ,getAttribute를 사용해서 저장소를 사용하는 법을 알아보았다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

27 Session 객체로 상태 값 저장하기

지난시간에 Application이라는 객체를 이용해서 상태값을 저장하고 다음요청이왔을때 이용해서 계산기를 구현해봤다.
Application말고 cookie session객체 도 있다.

오늘은 Session으로 바꿔보고 Session과 Application의 차이를 알아보자

위의코드는 application을 session으로 바꾸고 HttpSession session =request.getSession();  세션객체를 사용한것밖에없다.
왜 이렇게 했냐면 Session객체도 Application 객체와 같이 상태를 저장하기 위해서 사용하기 때문이다. 실행해서 결과가 같은지 확인해보자

어플리케이션이랑 Session이랑 결과가 똑같다! 그러면 두개중에 아무거나 사용해도 되는것일까? 그러지 않다.
이름에서도 알수있듯이 Application객체는 Application 전역에서 사용이가능하고 Session객체는 Session 전역에서 사용할수있다.

Session의 의미는 무엇일까? Session= 현재 접속이라는 뜻이다. 사용자별로(세션마다) 공간이 달라진다.
사용자마다 다른 세션공간을 가진다.

서버를 껐다가 다시켜보자

(현재 브라우저인 크롬)에서 실행해서 결과값을 보고 (다른 브라우저인 엣지)에서 들어가서 =을 눌러보면 원래 값을 반환해야하는데 에러가 발생했다. 값을 꺼내는데 값이 없기때문에 NullPointer Exception이 발생했다. 

브라우저가 달라지면 사용자가 달라진다? 서버에서는 사용자를 어떻게 식별할까? 다음시간에 배울것이다.

그러면 이번에는 같은 브라우저를 새로 실행해서 똑같은 과정을 거치면 같은 브라우저로 실행해 원래 입력했던 값이 계산되어 화면에 반환된다.

작업관리자를 열어서 이유를 확인해보면 크롬이 여러개의 프로세스가 아니라 크롬이 여러개의 창을 하위 흐름을 가지고있는 스레드로 띄우게 된다.

프로세스가 가지고있는 흐름을 쓰레드도 가지기 때문에 같은 사용자=같은세션으로 가지게된다.

웹서버는 사용자는 어떻게 구별할까? 다음시간에 세션이라는것을 공부해보자!

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------








-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------















-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


