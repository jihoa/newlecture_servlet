02 웹서버 프로그램이란

그렇다면 웹서버 프로그램은 무엇인지 이해하는것이 중요하다

예전에는 서버프로그램이라는것이 없었다.
콘솔,윈도우 프로그램 이정도 차이

사용자가 컴퓨터를 바로 사용하는것이었다.

하지만 
본점과 원산지가 있는데
(클라이언트) (서버)
본점에서 원산지에 있는 데이터를 보고싶어서 나누게 되었다.
옛날에는 서버 클라이언트 동일한언어로 만들었는데 불편한점이 생김
원래는 업데이트시 설치 재설치를 했는고 데이터전송 구현의 어려움이 부담되어서 웹을 사용하기 시작하였다.

웹프로그래밍이란 서버 클라이언트 프로그램이 아니라
웹에 서버클라이언트를 얹음

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

03 웹서버 프로그램과 Servlet

WEB vs WAS
WEB은 WEB서버에 문서만 있는것이다
WAS 사용자가 요구하는 내용이 동적이면 실행할수있는 DB와연동가능한것이 WAS (서비스를 할수있는 녀석이 추가적으로 설치되어있어야한다.)

WAS 구성요소
1.Server app = 동적으로 요구하는 내용을 문서로 만들어줄수있는것
2. WAS = 코드를 찾아서 실행해줄수 있는 환경 Tomcat

웹문서를 제공해주는 녀석 = webserver

Servlet은?(서버 어플리케이션 조각)
사용자가 요청하는 내용 GET:list/reg/edit/del

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

04 톰캣9 설치하기(환경설정)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

05 톰캣9 설치하기- 웹문서 추가해보기
- 웹서버는 예약되어있는 특정폴더가있고 그폴더에다가 문서를 저장하고 다른 원격에있는 컴퓨터 브라우저에서 리소스 이름을 입력하면 그 문서를 보여준다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

06 톰캣9 설치하기 Context 사이트 추가하기

Context란?(가상 경로)
사이트가 커지다보면 파일 디렉토리가 많아질것이다.
물리적으로는 두개의 사이트인데 실제는 하나의 사이트로 돌아가게 하는것이다.
규모가 클경우에는 컨텍스트를 나눠서 작업하는 경우도있다.

      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
	<Context path="it" docBase="C:\tools\apache-tomcat-9.0.41\webapps\ITWeb" previledged="true" />	//이 줄을 추가해준다.
추가하게되면 localhost:8080/it/ 로 접근이 가능하다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

07 처음으로 서블릿 프로그램 만들어보기
-왜 웹서버 응용 프로그램을 Servlet이라고 명칭할까?

Servlet은 기능에따라 나눠져있다.
원래 Javas는 main() 함수를 중심으로 만든다.
service()라는 함수로 만든다.

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request
			, HttpServletResponse response)
			throws IOException, ServletException
	{
		System.out.println("hello Servlet");	//서버 콘솔에 출력된
	}
}
이런식으로 작성한 후에 cmd 에서 해당경로 에서 javac -cp <servlet-api.jar 경로> Nana.java 를 실행하면 에러없이 돌아가면완료된것
$javac -cp C:\tools\apache-tomcat-9.0.41\lib\servlet-api.jar Nana.java

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

08 서블릿 객체 생성과 실행방법
지난시간에 nana파일을 컴파일해서 클래스파일로만들었음

둬야하는 위치
/
WEB-INF/				// 루트 아래에 WEB-INF 가 없으면 만들어야한다.
	web.xml
	classes/			//그아래에 classes 밑에다가 넣어야한다.
		Nana.class

넣고나서 http://newlecture.com/web-inf/classes/Nana.class
이렇게 하면 절대로 되지 않는다. 이걸 사용자가 요청하는것도 문제고 요청한다고 주는것도 문제다.
WEB-INF는 서버쪽에서만 사용할수있다. 클라이언트는 요청할수가없다.(비공개 영역)

사용자가 요청하는 방법
web.xml에서 URL 과 매핑된 Servlet 코드를 찾아서 실행 
(약속된 매핑방식으로 요청)

-web.xml

<servlet>
	<servlet-name>na</servlet-name>
	<servlet-class>Nana</servlet-class>	//2. 해당하는 클래스를 실행하겠다.
</servlet>
<servlet-mapping>
	<servlet-name>na</servlet-name>
	<url-pattern>/hello</url-pattern>	//1.hello라고 요청했을때
</servlet-mapping>

이렇게 등록을 해놓으면 사용자가 http://localhost/hello 를 입력했을때 hello라고 요청하고 요청에 해당하는 클래스를 실행해주겠다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

09 서블릿(Servlet) 문자열 출력 

자바 웹프로그래밍 
웹이 담당하고있는 부분은 UI ,UI는 콘솔UI  윈도우UI 두개로 나뉨


import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request					//HttpServletRequest 입력도구 
			,HttpServletResponse response)				//HttpServletResponse 출력도구	
			throws IOException, ServletException
	{
	 OutputStream os = response.getOutputStream();				//출력이나 입력을 할때는 Stream 을 쓰는것이 기본이다.
	 PrintStream out = new PrintStream(os,true);					//byte나 바이너리로 출력할것이 아니기때문에 PrintStream 객체를 사용한다. 쉽게 출력가능 true: flush이다. 글자하나썼다고해서 보내는게아니고 버퍼가 8KB채워야보내는데 그냥 보내라
	 out.println("Hello Servlet!!");
	}
}

뭐하나 수정하면 절차가 불편하다. 그래서 이클립스를 사용하는것이다.

문자열 출력이 기본이라면 이렇게 복잡하게 안해도된다 파일을 받아서 바이너리로 출력한다면 위와같이하지만
문자열을 출력할때는 PrintStream을쓰고 PrintStream을 기본적으로 제공해주는 Getter가 있다.

public class Nana extends HttpServlet
{
	public void service(HttpServletRequest request					//HttpServletRequest 입력도구 
			,HttpServletResponse response)				//HttpServletResponse 출력도구	
			throws IOException, ServletException
	{

	 PrintWriter = response.getWriter();							//자바에서는 Stream Writer두가지있는데 Writer는 다국어를 지원하기 때문에 Writer를 사용한다.
	 out.println("Hello Servlet!!");
	}
}
 
우리는 앞으로 간단하게 Writer를 얻어서 사용할것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10 웹 개발을 위한 이클립스 IDE준비하기
도구를 통합시켜놓고 쉽게 개발할수있는 환경이있다. 일반적으로 자바로 개발할때는 이클립스 인터프라이즈 버전을 사용한다.

코드를 만들게 되면

코드수정=>컴파일=>배포=>톰캣 서버 재시작 => 브라우저로 요청
이과정을 거치는데 이클립스를 사용하면 Ctrl + F11을 누르면 해결된다.

프로젝트 생성시 New=> Dynamic Web Project
이렇게 하면 서블릿 프로젝트가 만들어지는것이 아니라 서블릿코드를 만들고 실행하기위한 환경이 만들어지는것이다. 
우리가 톰캣을 설치하기는 해씨만 was는 톰캣만 있는것이아니다.
그래서 톰캣 9.0 선택하고 톰캣의 위치 홈디렉토리를 찾아주면 끝난다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11 이클립스를 이용한 서블릿 프로그래밍

ctrl+f11 을 누르게되면 톰캣을 설정해놨는데 그것의 복사본이 생기는 것이다.
창이뜨는것은 서버설정을 하겠다라는 뜻.
실행이되었을때 이클립스 내에서 브라우저가 실행되는데 그것을 크롬이나 다른 브라우저로 설정할수도 있다.
window=> Web Browser 에서 선택하면된다.

html의 경우

프로젝트 생성후에 홈디렉토리는 WebContent가 된다
홈디렉토리에있는 문서를 그냥 요청한것이다. 컨텍스트 이름이 루트에 해당하는 프로젝트는 컨텍스트 명을 갖는것이 좋은것이 아니다.
기본프로젝트이기때문에 컨텍스트명을 프로젝트명으로 쓰지않을것이다.

컨텍스트명 변경 방법
프로젝트 오른쪽클릭=> properties=>Web Project Settings

서블릿의 경우
패키지를 만들기위해서 Java Resources 로 간다 src라는곳에다가 만든다 기존에는 패키지명없이 만들었는데
Package명은 com.newlecture.web 		// newlecture에서만드는 웹페이지
로 만들자

-Nana.java

package com.newlecture.web;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		PrintWriter out = resp.getWriter();
		out.println("hello!");
	}
}

다 작성하고나서 실행을하려면 매핑이 되어있어야하는데 매핑하기위해서는 web.xml에다가 매핑을했었다.
WEB_INF안에 web.xml이 없으면 복사해온다.

-web.xml
<servlet>
	<servlet-name>na</servlet-name>
	<servlet-class>com.newlecture.web.Nana</servlet-class>		//원래는 <servlet-class>Nana</servlet-class> 클래스명만 적었지만 패키지명도있으면 적어야한다.
</servlet>

<servlet-mapping>
	<servlet-name>na</servlet-name>
	<url-pattern>/hello</url-pattern>
</servlet-mapping>

이렇게 까지 바꿔주면 전에는 Nana.java코드를 바꿔주었을때 실행하고 컴파일하고 배포하는 과정을 거쳐야하지만 ctrl+F11을 눌러주면 해결된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

12 어노테이션을 이용한 URL 매핑

일단 어노테이션이란?
ex)
@WebServlet("/hello")		//클래스나 메소드에 붙어져있는 주석이다.
				// 원래 주석은 컴파일러에 의해서 사라지지만 어노테이션은 컴파일러에 의해서 사라지지 않는다. 메타데이터라고 부르기도한다.


web.xml에다가 서블릿과 URL을 매핑했는데 어노테이션을 이용해서 서블릿과 URL을 매핑하는 법을 알아보자
어노테이션을 이용해서 실행하는데 영향을 줄수있다. 어노테이션으로 매핑정보를 실을수도 있다,
매핑정보를 남길수도있다. web.xml 안가도 된다.

web.xml에서

서블릿 2. 대에서는 web.xml에서만 매핑이가능했다 하지만
서블릿 3. 대에서는

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="false">		// 매핑정보를 설정할때 true로 하게되면 모든 메타데이터(설정)는 web.xml에 있다.
					// false로 할시에 여기외에도 어노테이션설정한게 있으니 찾아봐라 라는뜻
					//true-> false로 바꿔주기

web.xml 설정만 바꾸고 실행을 하게되면 안된다.

다시 서블릿 파일인 Nana.java로 돌아가서

@WebServlet("/hi")를 import문 밑에다가 추가해준다.
성공

Web.xml도 가능하고 어노테이션도 가능한데 어노테이션이 더 쉽다. 그리고 분업을할때도 훨씬 깔금하게 작업이 가능하다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

13 서블릿 출력 형식을 지정해야 하는 이유

서블릿을 출력할떄 출력을 어떻게하고 클라이언트는 어떻게 이해할까?

public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		PrintWriter out = resp.getWriter();
			for(int i=0; i<100; i++)
			out.println((i+1)+":Hello Servlet!!");
	}
}
이 코드를 실행해보자
크롬에서는 prinln이 적용되었고 익스플로러 에서는 print로 적용이되었다.
익스플로러 처럼 떠야하는것이 정상이다 왜냐하면 웹문서로 인식했기때문에 <br> 태그를 통해서만 내려쓰기가 되어야지 정상이다.

그래서 <br>을 추가해서 out.println((i+1)+":Hello Servlet!!<br >"); 돌려보자
익스플로러는 br태그를 정확하게 인식하였지만 크롬에서는 br문자가 그대로 출력이 되었다.
왜 이러냐면 브라우저가 자의적인 해석을 했기 때문이다.
익스플로러는 html로 해석하고
크롬은 text로 해석한다.
어떤 내용을 클라이언트에게 보낼때는 형식을 정해주는게 중요하다.

다음시간에는 문서를 보낼때 어떤형식으로 보낼때 어떻게 보낼지 한글을 쓰면 깨지는데 안깨지게 하는것을 알아볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

14  한글과 콘텐츠 형식 출력하기

서블릿을통해서 문자를 보내봤는데 사용자가 컨텐츠의 형식을 자의적으로 해석했다. 하지만 원래는 정해주고 보내주는것이맞다.

package com.newlecture.web;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/hi")
public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		resp.setCharacterEncoding("UTF-8");		//인코딩방식을 UTF 로 정하자! 이걸안하면 ??으로 뜸
		resp.setContentType("text/html; charset=UTF-8");	//받은것을 어떻게 해석할까 콘텐츠타입은 무엇인지 정의하는 문구 UTF-8로보냈고 charset=UTF-8이기때문에 UTF-8로 읽자 더불어서 이녀석이 html문서이다.
		PrintWriter out = resp.getWriter();
		for(int i=0; i<100; i++)
			out.println((i+1)+":안녕 <br />");
		
	}
}



하지만 이렇게 했음에도 불구하고 뚬궶 이런식으로뜬다.
?? 나오는것은 아예 잘못전달 뚬궶은 인코딩을 바꿔주면 해결되는것
크롬 개발자 도구에서 응답 헤더에 콘텐츠가 UTF-8 로 읽어져야한다고 심어줘야한다. 이렇게하지않으면 글자가 깨진다.
서버에서 심어주도록하자
resp.setContentType("text/html; charset=UTF-8"); 을작성해주고나면 한글도 잘표시된다.
그리고 다시 크롬 개발자 도구에 가보면 Content-Type: text/html;charset=UTF-8이 응답헤더에 있는것을 확인할수 있다. 


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

15 GET 요청과 쿼리스트링

지난시간에 한것은 출력방법이다. 어떻게 출력할것인가? 주의사항 인코딩방식 한글깨지는것 등등 배웠다.
이번시간은 사용자가 입력한거 처리하는것 사용자의 입력이라고 하는 것은 결국은 나한테무언가를 요청하는것이다
입력과 요청은 뗄래야 뗄수가없다. 요청할때 전달하는값을 어떻게 받을것인가?

사용자의 요청의 기본은 GET 요청이다.

기본적으로 웹이라는것은 사용자가 무언가를 요청하게 되어있고 서버가 그에 준하는 응답을 하게되어있다.
무엇을 달라고하는 요청에는 옵션이 있을 수가 있다.


 http://localhost/hello   => GET
 http://localhost/hello?cnt=3   => GET		//쿼리 스트링: ?를 쓰고 키값을 전달할수있다. 
					//추가적으로 옵션을 읽어서 그옵션에 맞는 문서를 줘야겠다 해서 쓴다.
					//hello를 3번만 반복하는 hello문서를 반복한다.

package com.newlecture.web;

@WebServlet("/hi")
public class Nana extends HttpServlet {
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {			//서블릿이라고 하는 service에서 보면 입력인 req, 와 출력인 resp가 있다.
		
		resp.setCharacterEncoding("UTF-8");
		resp.setContentType("text/html; charset=UTF-8");
		
		PrintWriter out = resp.getWriter();
		
		int cnt = Integer.parseInt(req.getParameter("cnt"));	//req도구에 getParameter가있다. 사용자가 전달할때 쿼리값을 심어서 전달하면 키워드를 읽을 수가있다. cnt라는 값을 읽는데 문자열로전달되기때문에 Integer.parseInt로 정수로 바꿔줌
		
		for(int i=0; i<cnt; i++)
			out.println((i+1)+":안녕 Servlet<br />");
		
	}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

16 기본값 사용하기

입력값을 처리하는 방법을 배웠는데 입력값이 없었으면 오류가 발생했다. 사용자가 입력안해도 오류가 안나게 하겠다 하려면 기본적으로 사용할 값이 있어야한다.
http//..//hello?cnt=20		//이게 기본적인 쿼리 스트링

http//..//hello?cnt=3		// "3"
http//..//hello?cnt=			// "" (빈문자열)
http//..//hello?			// null
http//..//hello			// null

String temp = request.getParameter("cnt");		// temp에 값을 받아놓음
int cnt= 0;					// 기본값으로 등록해놓음
if(temp != null && !temp.equals(""))					// temp가 null이 아니고 tmep값이("")이아니면 왜냐하면 빈문자열이오면 인트형으로 못바꾸기때문 cnt 를 temp값으로 바꿈
	cnt = Integer.parseInt(temp);
for(int i=0; i<cnt; i++)				
	out.println((i+1)+":안녕 servlet!!<br/>");

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

17 사용자 입력을 통한 GET 요청

Get요청할때 값을 사용자가 입력할수있게 하는법을 배울것이다.
이렇게 만들어주는데
<body>
	<div>
		<form action="hi">		//http://.../hi?cnt=3   입력된값이있으면 cnt= 입력된값으로 쿼리스트링을 만들어줌
			<div>
				<label>"안녕하세요"를 몇번 듣고 싶으세요?</label>
			</div>
			<div>
				<input type="text" name="cnt"/>
				<input type="submit" value="출력"/>
			</div>
		</form>
	</div>
</body>


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

18 입력할 내용이 많은 경우는 POST 요청

Get 요청할때 queryString을 이용해서 값을 전달할수 있다. 그리고 그것을 서버쪽을 담당하는 우리는 그것을 서버에 받아서 값 이용가능
입력값이 많을경우에는 예를들어

양파는 빼주시고요
고기는 중간정도로 익혀주시고
케찹은 많이 주시고
치즈는 반만 주시고
상추는 양배추로 바꿔주시고 등등 많약 입력값이 많으면? 받는쪽에서는 기억하기 힘들다.


그래서 과정을 만들어서

1.햄버거를 위한 주문서를 주세요 =>Get 요청을 한다.
 
2.주문서를 작성해서(양파=빼고&고기=중간&치즈=반만$상추=/..) =>Post요청을 보낸다.

3.요청을 처리해서 햄버거를 준다.

<body>
	<div>
		<form action="notice-reg">
			<div>
				<label>제목: </label>
				<input type="text" name="title">
			</div>
			<div>
				<label>내용: </label>
				<textarea name="content"></textarea>
			</div>
			<div>
				<input type="submit" value="등록"/>
			</div>
		</form>
	</div>
</body>

요청을 하게된다면 쿼리스트링으로 URL으로 나타나게된다.
이렇게되면 문제가 두가지있다.
1.URL에 붙어가는경우에 길이 제한이있다.
2. 달라고하는것이 문서라면 문서의 옵션값이 쿼리스트링이다. 장문의 내용을 보내는것은 올바르지않다.


<form action="notice-reg"> 	//아무것도 옵션을 정하지않으면 쿼리스트링으로 전달한다.
<form action="notice-reg" method="post"> 	//형식으로 하게 된다면 POST방식으로 전달하게된다면 이것은 사용자가 입력받은것을 제출하는것이다. 입력받은것이 많기때문에 URL로 제출하지않는다.
					
크롬 개발자도구에서 네트워크로 들어가서 어떻게 전달되었는지 확인해보자.
Form Data 항목에 들어가보면
title=aaaa&content=bbbb
이렇게 요청바디로 전달됐다. 길이 제한도 없다. 큰데이터를 보낼수있다.

그렇다면 한글을 써서 보내보자! 한글이 깨졌다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

19 한글 입력 문제

한글 POST 할때 깨지는 문제가 있었다 어떤게 문제고 어떻게 해결하는지 알아보자
저희가 한글을 출력하는데에 문제가 없었다.

이번문제는 전달(POST)하다가 문제가 발생했을것이다.

UTF-8은 멀티바이트 문자이다. 문자하나당 숫자하나가 연관되어있다. 한글은 2Byte 영문자 1Byte
톰캣의 기본적인 인코딩 방식은 ISO-8859-1 방식이어서 에러가 난것이다!

UTF-8 로 바꾸는 방법은 두가지가있다!

1.server.xml 설정을 바꾸는 방법
 <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort=8443" URIEncoding="UTF-8" />
하지만 이방법은 잘 사용되지 않는 방법이다. 왜냐면 톰캣서버에는 여러개의 서비스를 돌릴수 있기 때문이다. 다른 서비스에 영향을 줄수 있기 때문이다.

2.Servlet 설정을 바꾸는 방법
request.setCharacterEncoding("UTF-8");

다음시간에는 한글설정을 필터라는 방식으로 설정하는 법을 배울것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

20 서블릿 필터(Servlet Filter)

WAS(톰캣)가 사용자로부터 요청이 들어오면 적정한 소프트웨어를 실행해서 결과를 돌려주도록 되어있다.
그 소프트웨어를 서블릿이라고 하는데 
서블릿을 실행하게되면 메모리상에 존재하게될텐데 그 공간을 Servlet Cotainer라고하고 WAS는 서블릿을 실행시켜서 결과를 돌려주게 되고 그리고 사용되지않으면 컨테이너에서 삭제

서블릿만 주구장창 만들었는데 또 만들수있는 오브젝트는 필터이다.
사용자로 부터 입력을 받을때는  request.setCharacterEncoding("UTF-8"); 설정을 해야한다. 그렇다면 톰캣이 사용하고있는 방식을 UTF8로바꾸면 어떨까? 들어오는 입력에대한 입력을 UTF8로바꾸면된다
하지만 그것은 부담스럽다 왜냐면 다른 서비스도 제공하기때문이다. 그러니까 우리꺼에만 영향을 주고싶은데 그렇다고해서 서블릿마다 이런작업하긴 불편하다. 그래서 중간에 위치할수있는 소프트웨어가 있다. 
요청이 들어오면 요청을 서블릿을 실행하는 쪽으로 가는데 이 소프트웨어는 가로채기가 가능하다. 수문장역할을 하는것이다 이 수문장녀석은 서블릿을 실행할지 말지도 결정이 가능하다. 모든 서블릿이 가지고있는 기본설정을
어차피 거쳐가는것이니까 다 영향을 주게할수도있다.
먼저 실행되는것이 기본적이지만 response에도 영향을 주게하는것도 가능하다. 이녀석을 Filter라고 부른다.

Filter를 만들어보자 원래있는 프로젝트에다가 만들지말고 새로운 프로젝트
com.newlecture.web.filter 프로젝트를 생성하고
그아래에 CharacterEncodingFilter를 만들자 Add를 눌러서 인터페이스를 추가하자 filter로 검색해서 javax.servlet.Filter 를 추가하자

생성하고 난 이후에 		System.out.println("hello filter"); 을 설정해주자
이렇게 필터를 생성하고 설정을 하면 어떠한 요청이 와도 필터가 자동으로 동작하게 된다. 요청이 올때마다 동작이되긴하지만 톰캣이 실행될때도 동작이된다.

web.xml 에서 필터를 설정하자. 
필터 설정할때 두가지가있다 서블릿처럼 xml도되고 어노테이션도된다 서블릿먼저하고 어노테이션으로 바꿔보자

-web.xml

<filter>										//현재 내가 어떤 클래스를 쓸까 와 어떤이름쓸지를 등록
	<filter-name>characterEncodingFilter</filter-name>
	<filter-class>com.newlecture.web.filter.CharacterEncodingFilter</filter-class>		//필터 패키지 + 필터 클래스명
</filter>
<filter-mapping>									//필터에대해서 어떤 매핑을 쓸까와 이름은 뭘로할지
	<filter-name>characterEncodingFilter</filter-name>
	<url-pattern>/*</url-pattern>						//어떤 URL을 사용할지를 정하는데 /*는 모든 URL
</filter-mapping>


noitce.reg가 정상적으로 실행되었는데 아무것도 안나온다. 왜 안나올까?  필터가 실행되었는데 서블릿실행으로 갈지말지는 필터가 결정하기 떄문이다.
필터라는 녀석을 두고

-CharacterEncodingFilter.java

public class CharacterEncodingFilter implements Filter {

	@Override
	public void doFilter(ServletRequest request
			, ServletResponse response
			, FilterChain chain)					// 이 흐름을 다음녀석에게 전달 해줄까 말까는 얘가 결정한다.
			throws IOException, ServletException {
		System.out.println("before filter");				//요청이오면 이게 실행
		req.setCharacterEncoding("UTF-8");				//모든 서블릿 실행전에 인코딩 작업할것이기 떄문에 여기다가 넣어준다.
		chain.doFilter(request, response);				//다음 필터 혹은 서블릿으로 실행되게 한다. 	
		System.out.println("after filter");				//다음 필터나 서블릿이 실행되고 나서 실행된다.

	}

}

어노테이션으로 하는 방법을 알아보자

-CharacterEncodingFilter.java

import java.io.IOException;

@WebFilter("/*")								// 이 문구만 사용해주면된다. 여러가지 불필요한 작업을 없앨수있다.

public class CharacterEncodingFilter implements Filter {


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

21 학습과제 (사용자 입력을 통한 계산 요청)

완료


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

22 과제풀이(사용자 입력을 통한 계산 요청)

계산을 요청하게되면 값이전달 전달되는값은 문자열 형태로간다.
프로그래밍은 보고따라하는게 아니라 직접해보는게 실력이 늘어난다.

com.newlecture.web 밑에 add 라는 자바파일을 추가하려고 한다. 
하지만 원래는 class를 클릭해서 클래스를 생성했지만, 오늘은 Servlet을 클릭할것이다. Servlet은 이클립스에서 제공하는 폼이고,
이것을 선택하게 되면 서블릿 클래스를 생성할수있다.

과정중에 URL 매핑도 수정할수있다. Add라는 파일명이지만 매핑은 add로 선택
그리고 다음을 눌러서 Inherited abstract methods(상속 추상 메소드)에 service만 선택 그리고 Finish

자동으로 생성해주는 코드다 보니 군더더기가 많이 있다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

23 여러 개의 Submit 버튼 사용하기

지난시간에 했던것은 버튼하나로 덧셈만되는것이었지만 이번시간에 할것은 버튼을 두개 만들어서 덧셈 뺄셈을 하게 할것이다.
덧셈과 뺄셈 어떻게 식별할까? 서블릿이 식별할줄알아야한다. 

add.html 을 복사해서 calc.html을 새로 만들자
com.newlecture.web 밑에 Add.java도 복사해서 calc.java를 만들어준다. 
복붙을 하게되면 문제가 되는것은 바꿀것은 바꿔줘야한다는것이다.
어노테이션 @WebServlet("/add") 를 @WebServlet("/calc")로 바꾸어준다.

calc.html 에서 form action도 calc로 바꾸어주자.
<input type="submit" value="덧셈"/>
<input type="submit" value="뺄셈"/>			//복붙해서 추가해주자

그리고 서버를 실행시켜서 확인을 해보게 되면 덧셈버튼 뺄셈버튼 둘다 동작이 똑같음을 알수있다.
우리는 어떻게 두개가 차이점을 알기위해서 어떻게 값이전달되는지 확인해야한다. 개발자도구로 가자
네트워크라는 탭을 선택하고 그래프에 아무것도 없어야한다. (있다면 clear를 누르자)

그리고 덧셈버튼을 누르면 서버에게 전달되는 POST 데이터를 구경할수있다.
누르면 요청했던 문서에대한내용이나오는데 calc를 클릭해보자

Form Data가 있는데 확인해보자
x=2
y=3 
(이런식으로 나와있다.)

view source로 보면 정리안된상태 x=2&y=3이라고 나온다. 값만 전달된다. 서버쪽에서는 어떤 버튼이 눌렸는지 알수가없다.
알수있게하는 방법이있다.

calc.html 로와서 버튼에 name값을 넣어주자
<input type="submit" name="operator" value="덧셈"/>
<input type="submit" name="operator" value="뺄셈"/>

이렇게 name에 같은 이름인 operator을 줬는데 왜냐면 다른입력 컨트롤과 달리 operator는 두개를 다 클릭할일이없다.
input이라는 녀석은 중요한것은 name값이 있으면 전달된다. 하지만 type="submit"은 선택된 놈만 전달된다. name 없으면 전달x 
(덧셈 클릭하면 덧셈 전달 뺄셈전달하면 뺄셈 전달)

코드를 수정하고 서버를 실행한다음 다시 개발자도구에서 확인해보자
Form data에 
x=2
y=3 
operator = 덧셈
(이런식으로 바뀐것을 확인할수있다.)

view source를 누르게되면
x=3&y=2&operator=%EB%8D%A7%EC%85%88 		//이런식으로 표현되는데 한글을 url방식으로 전달되기는 무리가있기에 인코딩된것

서버쪽에서는 operator의 값을 식별할수 있게 되었다. 

String op = request.getParameter("operator");			//operator라는 파라미터를 가져온다.
		
		int x= 0;
		int y= 0;
		int result=0;				//result 초기값은 0으로 선언
		
		if(!x_.equals("")) x= Integer.parseInt(x_);
		if(!y_.equals("")) y= Integer.parseInt(y_);
		
		if(op.equals("덧셈"))			//operator 값인 op가 덧셈이면 덧셈수행
			result = x+y;
		else					//그외(뺄샘이면) 뺄셈을 수행
			result = x-y;


버튼이 두개가있어도 서버에서 선택적으로 결과를 처리할수 있다는것을 배웠다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

25 상태 유지를 필요로 하는 경우와 구현의 어려움

웹개발하다보면 상태유지에대한 필요성과 방법이 중요하다. 웹이라는 녀석은 어플리케이션이 조각나있다. 서블릿 역시
전역변수라는 개념이 필요한데 없다. 전역변수처럼 값을 유지해줘야하는데 어떻게 해야할까>

지역변수값을 받아서 어디다가 저장해줘야한다. 서블릿들간에 값을공유할수있는게없다.
그래서 세가지를 사용한다. 서블릿들이 살았다 죽었다를 반복하면서 값이 사라지지않고 담을수있는 세가지이다.

application
session
cookie

일단 세가지의 도구를 사용하는 법을 배워볼것이다.

WebContent 아래에 있는 calc를 복사해서 calc2를 만들어보자

-Calc2.html-

<body>
	<form action="calc2" method="post">				// action값을 요청하는 컴포넌트값인 calc2로 바꿔주자
		<div>
			<label>입력 : </label>
			<input type="text" name="v"/> 			//입력박스가 두개가 아니고 하나로 만들어서 하나씩 하나씩 전달하게하자
		</div>
		<div>
			<input type="submit" name="operator" value="+"/>
			<input type="submit" name="operator" value="-"/>
			<input type="submit" name="operator" value="="/>
		</div>
		<div>
			결과 : 0
		</div>
	
	</form>
</body>

 실행을해보게 되면 좀 더 계산기 같은 형태로 바뀌었다. 2를 입력을하고 +를 누르게 된다면 그러면 2라는숫자와 덧셈이라는 오퍼레이터가 전달될것이다.
서버쪽에서는 무조건 저장해야하고 페이지를 다시 돌려줘야한다. 그리고 3을 누르고 = 를 누르면 어디서 꺼내가지고 값과 연산자에 의해서 계산을해서 돌려줘야한다.

일단 프론트는 완성했으니까 서버쪽 페이지는 어떻게 해야하냐면

Calc.java를 복사해서 Calc2.java로 복사하자

Calc2로 만들었으니 어노테이션도 바꿔주자

@WebServlet("/calc")  => @WebServlet("/calc2")

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

26 Application 객체와 그것을 사용한 상태 값 저장

상태를 저장하기위해서 다뤘던정보를 잠깐 저장하기위해서 Application 객체를 사용하는 방법을 알아보자

ex) 1번 서블릿을 여러분이 요청하게되면 1번 서블릿이 메모리에서 처리하면 1번서블릿이 메모리에서 사라진다. 
그래서 서블릿이라는 녀석을 사용할때 그들간에 그자신간의 데이터를 저장할수있는 메모리 저장소를 사용하는것이 필요한데 그것이 서블릿 Context이다. 
어플리케이션을 만들다보면 API중에서 Context 라는 이름을 가진아이들이 많다. Context라는 것은 문맥,책갈피 라는 사전적 의미를 가지고있다.
책갈피는 책을 이어갈수있도록 하는 상태값을 표시하는 역할을 한다. 책을 읽을때 다음에 다시 읽을수있도록 해주는 공간이다.

서블릿 컨텍스트:A라는 서블릿이 만든 결과를 저장하면 B라는 서블릿이 그 결과를 이어서 새로운 결과를 만들 수 있도록 하는 상태 저장공간

웹어플리케이션에서는 어플리케이션 저장소라고 부르기도 한다.

서버쪽에서 사용자 전달한 값이 있을텐데 그값을 저장할수있느냐, 다음 요청에서 그값을 꺼내볼수있느냐 그것이 우리가 알아볼내용이다.

@WebServlet("/calc2")
public class Calc2 extends HttpServlet {
	
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		ServletContext application =request.getServletContext();						//이 값을 저장해야하는데 어디다 저장해야하는가? request에보면 ServletContext()가있다. 이것이 어플리케이션 저장소이다 application이라는 변수에다가 getservletCOntext()를저장하자
		response.setCharacterEncoding("UTF-8");
		response.setContentType("text/html; charset=UTF-8");
		
		String v_ = request.getParameter("v");											//사용자가 전달하는 값은 하나만 전달한다.
		String op = request.getParameter("operator"); 									//그리고 오퍼레이터를 같이 전달한다.
		
		int v= 0;																		// 기본값이 필요할까도 생각을 해봐야한다. 전달하는 내용이 값이없을때 기본값으로 받아야하나? 값입력x시 0으로 처리하기위해 v=0 기본값세팅
		if(!v_.equals("")) v= Integer.parseInt(v_);
		
		//계산
		if(op.equals("=")) {															//왜 if문에 =(equal)로했냐면 덧셈과 뺄셈은 하는일이 같다. 하지만 =는 계산하는것이다. 
																						//아래에서 값을 읽어와야한다. 하나는 앞에서 저장했던내용이고 하나는 지금가져온내용으로 두가지를 읽어야한다.
			
			int x = (Integer)application.getAttribute("value");							//앞에서 저장한값을 어플리케이션저장소에서 꺼내와야하는데 application.getAttribute("담을떄사용했던 값")메소드를 사용한다. 그리고 (Integer)을 안했을 떄 빨간줄이 뜨는것은 Object로 값을 반환하기 때문이다.
			int y = v;																	//지금사용자가 저장한값
			String operator= (String)application.getAttribute("op");					//그래서 그 밸류값과 앞에서 저장했던값을 꺼내서 덧셈을 할지 뺄셈을 할지는 사용자가 저장했던 operator값을 꺼내서 봐야한다. 어플리케이션 저장소에서 읽어오자
			int result=0;
			
			if(operator.equals("+"))			
				result = x+y;
			else
				result = x-y;
			response.getWriter().printf("result is %d", result);
		
		
		}
		// 값을 저장
		else {
			application.setAttribute("value", v);										//application에다가 두가지를 저장하자 v(값), op(연산자) setAttribute에다가 저장한다 어떻게 저장하냐면 map Collection처럼 key 와 value를 넣어준다.
			application.setAttribute("op",op);  						 				//오퍼레이터도 같은 방식으로 저장해주기위해서 key와 value를 저장해주자 이것들을 두고두고 쓸수있다.																						//전달된내용이 op이 뭐냐인가에 따라서 저장해야할수도있고 계산이 될수도있다.	
		}		
	}
}

다 되는데 왜 화면이 하얗게 질리는지 그것이 아쉽지만 잘 동작하긴한다. 다음시간에 왜그런지 알아보자 중요한것은 application 저장소를 활용할수있는지가 중요하다.
다음시간에 세션과 쿠키를 이용해서 저장소를 사용하기위한 적절한 시기와 장소를 알아보는것으로 하자.

SetAttribute ,getAttribute를 사용해서 저장소를 사용하는 법을 알아보았다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

27 Session 객체로 상태 값 저장하기

지난시간에 Application이라는 객체를 이용해서 상태값을 저장하고 다음요청이왔을때 이용해서 계산기를 구현해봤다.
Application말고 cookie session객체 도 있다.

오늘은 Session으로 바꿔보고 Session과 Application의 차이를 알아보자

@WebServlet("/calc2")
public class Calc2 extends HttpServlet {
	
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession session =request.getSession();
		
		
		response.setCharacterEncoding("UTF-8");
		response.setContentType("text/html; charset=UTF-8");
		
		String v_ = request.getParameter("v");							//사용자가 전달하는 값은 하나만 전달한다.
		String op = request.getParameter("operator"); 						//그리고 오퍼레이터를 같이 전달한다.
		
		int v= 0;										// 기본값이 필요할까도 생각을 해봐야한다. 전달하는 내용이 값이없을때 기본값으로 받아야하나? 값입력x시 0으로 처리하기위해 v=0 기본값세팅
		if(!v_.equals("")) v= Integer.parseInt(v_);
		
		//계산
		if(op.equals("=")) {									//왜 if문에 =(equal)로했냐면 덧셈과 뺄셈은 하는일이 같다. 하지만 =는 계산하는것이다. 
												//아래에서 값을 읽어와야한다. 하나는 앞에서 저장했던내용이고 하나는 지금가져온내용으로 두가지를 읽어야한다.
			
			int x = (Integer)session.getAttribute("value");	
			int y = v;									//지금사용자가 저장한값

			String operator= (String)session.getAttribute("op");
			int result=0;
			
			if(operator.equals("+"))			
				result = x+y;
			else
				result = x-y;
			response.getWriter().printf("result is %d", result);
		
		
		}
		// 값을 저장
		else {
			session.setAttribute("value", v);
			session.setAttribute("op",op);


위의코드는 application을 session으로 바꾸고 HttpSession session =request.getSession();  세션객체를 사용한것밖에없다.
왜 이렇게 했냐면 Session객체도 Application 객체와 같이 상태를 저장하기 위해서 사용하기 때문이다. 실행해서 결과가 같은지 확인해보자

어플리케이션이랑 Session이랑 결과가 똑같다! 그러면 두개중에 아무거나 사용해도 되는것일까? 그러지 않다.
이름에서도 알수있듯이 Application객체는 Application 전역에서 사용이가능하고 Session객체는 Session 전역에서 사용할수있다.

Session의 의미는 무엇일까? Session= 현재 접속이라는 뜻이다. 사용자별로(세션마다) 공간이 달라진다.
사용자마다 다른 세션공간을 가진다.

서버를 껐다가 다시켜보자

(현재 브라우저인 크롬)에서 실행해서 결과값을 보고 (다른 브라우저인 엣지)에서 들어가서 =을 눌러보면 원래 값을 반환해야하는데 에러가 발생했다. 값을 꺼내는데 값이 없기때문에 NullPointer Exception이 발생했다. 

브라우저가 달라지면 사용자가 달라진다? 서버에서는 사용자를 어떻게 식별할까? 다음시간에 배울것이다.

그러면 이번에는 같은 브라우저를 새로 실행해서 똑같은 과정을 거치면 같은 브라우저로 실행해 원래 입력했던 값이 계산되어 화면에 반환된다.

작업관리자를 열어서 이유를 확인해보면 크롬이 여러개의 프로세스가 아니라 크롬이 여러개의 창을 하위 흐름을 가지고있는 스레드로 띄우게 된다.

프로세스가 가지고있는 흐름을 쓰레드도 가지기 때문에 같은 사용자=같은세션으로 가지게된다.

웹서버는 사용자는 어떻게 구별할까? 다음시간에 세션이라는것을 공부해보자!

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

28 WAS가 현재사용자(Session)을 구분하는 방식

지난시간에 어플리케이션이아닌 세션을 이용해서 상태값을 저장하는 방법을 배움, 근데 어떻게 웹서버는 사용자를 식별할까?

브라우저를 이용해서 서버에다가 무언가를 요청하게됨 프로그램에서 다른서블릿에게 전달,저장 하고싶은 것이 있으면 저장하는 공간이 Application공간

개인별 사물함처럼 개인의 정보를 저장하는 Session공간이 따로있다. 
 
사용자가 요청이오면 요청이라는것은 서버상에있는 요청, 서블릿이 실행된다. 이 요청이 처음오면 새로운 사용자가 된다.
세션에 그 사용자는 새로운 사용자가되는것이다. 다만 새로운 사용자든 기존의 사용자든 기존의 서블릿이 실행되다가 Application에 기록하는것이 가능하다.
하지만 세션은 불가능하다.(SID 가 없기 때문에) 

처음에 요청이오면 Sid 없어서 세션을 못쓰고 Application공간을 사용해서 SID를 부여해준다. ex) SID:107 

107번이라는 Session 공간에 저장된다. 다음에 오게 되면 SID 107을 사용해서 Session에다가 107이라는 값을 넣게 된다.

만약에 브라우저가 달라졌다고 가정하자. SID가 없이 요청이온다 WAS에서 Session공간에 저장된것이 없으므로 다시 Application 공간에서 요청하게된다. 번호를 부여한다.
번호가 부여되면 사용자가 달라진것이다 .물리적으로는 한사람이 두개의 브라우저를 띄울수있지만 WAS에서는 다른 사용자로 본다!

같은브라우저라면 항상 같은값을 준다. 그러다가 브라우저를 닫게 된다면 값이 사라진다. 다시열면 SID가 없기때문에 아까 저장했던 107번이 사라졌다.

지난번에 했던 예제에서 Network -> calc2를 누르고 Header 정보를 보게 되면 
Cookie: JSESSIONID=FE5A62D3E36E3EA385FE5D39A7C42983
이런식으로 나오게 된다. 이 ID를 가져가게되면 같은유저라고 보게되고 다른 ID를 가져가면 다른유저라고 인식한다. 다른세션이됨

이것을 확인해보기 위해 (같은브라우저인 크롬)에서 새창을 켜고 url을 입력하고 Header 정보를 확인해보면 같은 SessionID를 가진것을 확인할수있다.
(다른 브라우저인 엣지를) 켜서 같은방법으로 확인해보면 SessionID가 다른것을 확인할수있다.(다른 사용자로 인식)

그러면 궁금한점! 브라우저 사용하지않고 누군가의 SessionID를 복사해서 사용하면 같은 사용자로 인식할까? 정답은 그렇다.
그래서 요즘 다양한 방식으로 세션아이디를 관리한다. 다른 웹서버같은경우에는 다양한조합을 통해서 사용자를 식별하려고 노력함

웹이라는 특성을 봤을때 사용자가 한번 요청하고 다음요청이 또올까? 그러면 서버는 우직하게 공간을 유지할까 정의할까?
-정의 한다. 언제 정의할까?
 - 세션은 몇가지의 추가적 기능을 가지고있다.

void set Attribute(String name, Object value)
지정된 이름으로 객체를 설정
void getAttribute(String name)
지정한 이름의 객체를 반환

//지난 시간에는 꺼내온다거나 저장한다같이 저장소의 의미로만 사용했는데

void invalidate()				//저장소를 비울때 사용되는 메소드이다.
세션에서 사용되는 객체들을 바로 해제

그런데 Invalidate 처럼 session은 Timeout을 사용한다. 중요한것은 이것이다.

void setMaxInactiveInterval(int interval)		//사용자가 요청을 했다. 그리고 요청이 안올수도 있기때문에 시간을 두는것이다 기본은 30분,30분이 경과되는순간 같은 세션ID를 가져오면 만료가 되어서 새로운걸로 인식한다.
세션 타임아웃을 정수(초)로 설정


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

29 Cookie를 이용해 상태값 유지하기

두가지외에 쿠키라는것을 이용해 상태값을 저장할수있다.

서버에다가 값을 넣었다가 값을 이용하는 방법은 크게 두가지이다. Application공간(모두 사용가능) Session(개인 사용가능)
Session or Application에 저정할것인지는 데이터의 속성에 따라서 적절하게 쓰면된다.
또하나 봐야될것이 무엇이냐면 피트니스 센터에 들어가는것이랑 정말 비슷하다. 공용 공간도 있고 사물함도 있다.

Cookie : 상태값을 클라이언트가 가지고있다가 가져왔다 가져왔다 하는것이다. 
왔다갔다해도 값은 유지가 된다. 

값을 저장할수있는공간
서버쪽에 저장:Application,Session
클라이언트에저장: Cookie

3가지 저장소를 쓸때는 특징과 장단점이 있다. 다음시간에 알아보자

쿠키를 사용하는 방법에 포커스를 맞춰보자

클라이언트가 서버에 요청할때 (Request) 가져갈수있는값 3가지

1. Header(브라우저가 알아서 담아줌)
-getHeader()		//헤더를 얻어올때사용
2. 사용자데이터(내가보내는 데이터) 
-getParameter() 		//Ap함수를 사용함
3. 쿠키를 가져간다.(브라우저가 보내줌)
-getCookie()		//쿠키를 얻는 함수

서버에서 클라이언트로 응답할때(Response) 가져갈수있는 함수
-AddCookie()		//Server에서 쿠키라는 녀석은 사용자에게 보낼때 addCookie라는 녀석은 보낸다. 브라우저에다가 저장하겠다 할때 사용한다.

쿠키를 이용하는 간단한 예제

1.쿠키 저장하기 	//서버쪽에서는 (상태)값을 저장해야겠다. 근데 Application에도 싫고 Session에도 싫다 그러면 클라이언트에 보내겠다.

Cookie cookie = new Cookie("c",String.valueOf(result));		//쿠키는 "c"(키)와 String.valueOf(result) (값)으로 나뉜다. (c라는 키로서 값을 보내게되면)
response.addCookie(cookie);					//addCookie라는것을 통해서 출력을하게되는것이다. 그러면 response에 심어진것을 브라우저가 읽을수 있다. 그것을 자기가 갖게된다.

2.쿠키 읽기
Cookie[] cookies = request.getCookies();			//브라우저가 그 사이트로 쿠키를 요청하면 서버에서는  getCookies() (복수형이다!) 배열로온다. 하나가 아니라 여러개일수 있기떄문에 키와 값 여러개로온다.
String _c="";

if(cookies != null)						//배열이니까 심었던 쿠키를 찾는 과정이 있어야한다. for문돌리면서 키값을 찾아서 키값에 해당하는 밸류를 찾아야한다.
	for (Cookie cookie : cookies)
		if("c".equals(cookie.getName()))
			_c = cookie.getValue();

이런 불편한점이있지만 사용자에게 브라우저에게 값을 위임했다가 가져올수있다. 


public class Calc2 extends HttpServlet {
	
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		Cookie[] cookies =request.getCookies();											//3.사용자가 쿠키를 보냈으니까 다음요청이 들어왔을떄 보내줄것이다. 그러기위해서 쿠키를 읽어야한다. 쿠키를 읽기위해 request.getCookie()메소드를 사용하고 쿠키가 Cookies라는 배열로 읽히기 때문에 Cookie[]라는 배열로 선언해준다.
		response.setCharacterEncoding("UTF-8");
		response.setContentType("text/html; charset=UTF-8");
		
		String v_ = request.getParameter("v");											
		String op = request.getParameter("operator"); 									.
		
		int v= 0;														
		if(!v_.equals("")) v= Integer.parseInt(v_);
		
		//계산
		if(op.equals("=")) {															
																	//4. 쿠키가왔으니 읽어야하는데 읽는곳은 이곳이다.  
			int x=0;														//6. x가 value가 담기는 값인데 일단 초기화 하도록하자
			for(Cookie c : cookies)												//8. 찾는작업이 여러번이니 for문 Cookies라는 배열에서 꺼내서 하나씩 Cookie c에 넣겠다.
			if(c.getName().equals("value"))	{										//5. 첫번째 쿠키를 꺼내면 getName()이름이있다. 이 이름이 "value"가 있는지? if문을 쓰자.
				x= Integer.parseInt(c.getValue());										//7.그 value가 찾아졌다하면 c.getValue()그 값을 가져온다 근데 빨간글씨뜬다 반환값이 String이라서그렇다 정수형으로바꾸자
				break;													//9. 조건문을 두개 문장이 들어갈건데 찾았으면 그만검색 break;
				}
			
			int y = v;																				
			String operator ="";												//10.op값을 쿠키에서 찾는과정 value와동일
			for(Cookie c : cookies)					
				if(c.getName().equals("op")){			
					operator= c.getValue();				
					break;									
					}
			int result=0;
			
			if(operator.equals("+"))			
				result = x+y;
			else
				result = x-y;
			response.getWriter().printf("result is %d", result);
		}
		// 값을 저장
		else {
			Cookie valueCookie= new Cookie("value", String.valueOf(v));								//1. 심는것이니까 여기서 부터 시작 Cookie를 키와 밸류값으로 각각 value와 op를 주자 빨간줄이 뜨는데 그이유는 op는 문자열 v는 정수형이어서다 그래서 문자열로 변환해주는 메소드인 String.valueOf(v)를 사용해주자 쿠키로 보낼수있는값은 문자열만 가능하기때문 문자열중에서도 UTF로 보내야한다. 쿠키라는 녀석은 문자열로만 저장하는 한계가있지만 JSON XML을 이용하면 다양한형태로 저장가능
			Cookie opCookie= new Cookie("op",op);
			response.addCookie(valueCookie);											//2-1. 쿠키 두개를 만들었을 뿐이고클라이언트에게 보내기위해서 addCookie()메소드를 사용하자
			response.addCookie(opCookie);											//2-2. 어떻게 전달이되냐면 response header에 심어지는 형태로 전달이된다. 이것이 클라이언트로 갔으니까 브라우저가 '쿠키가 왔네!' 하면서 브라우저가 잘저장하고있을것이다.
		}															//2-3. 쿠키가 전달되면 크롬 ▶ 설정 ▶ 사이트설정에 보면 쿠키라는 항목이 있다. ▶쿠키 에서 사이트에서 쿠키 데이터를 저장하고 읽도록 허용(권장) 이라는 항목이있는데 요즘은 대부분 허용하는데 안될수도있다는 것을 알아둬야한다. 그리고 쿠키데이터보기라는 항목이있는데 클릭해보면 ▶ 사이트 주소가 있다 사이트주소들이 나한테 보낸 쿠키들이보인다. 클릭해보면 쿠키값도 확인할수있다. 언제 생성 만료도 확인가능하다. 
	}
}



이렇게 불편하기는하지만 쿠키라는것이 있기 때문에 또다른방법이 생긴것이다. 쿠키를 이용하는방식으로 코드를 바꿔봤다.
쿠키를 읽을때에는 여러개의 쿠키가 있을수 있으므로 찾아봐야한다는 불편함이 있을수있지만 쿠키를 이용해서 사용자 브라우저에 값을 저장했다가 사용할수 있다.
장단점은 다음시간에 알아보도록하자 
실행을해봤더니 결과가 똑같다! 왜 세가지 방식을 쓸까? 세가지방식을 쓰라는게 아니라 그 장단점을 보고 적절하게 사용하라는것이다.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

30 Cookie의 path 옵션

Application Session Cookie의 차이점을 알아보려했으나 Cookie의 옵션을 깜빡하셔 Cookie의 옵션부터 한다.

쿠키라는것을 사용할때 꼭알아야되는 점 2가지

1. Servlet을 여러개를 만들것이다. 서블릿마다 값을 저장할것이 있어서 쿠키를 저장한다고하자. 그렇다면 서블릿을 요청할때 브라우저가 쿠키를 서버로 가져갈텐데 서블릿마다 쿠키가 다를까? 같을까? 상식적으로 생각하면 같으면안된다. 
쿠키를 설정할때 나한테 올때만 or 이 범주안에 있을때만 가져와라 라고 설정이 가능해야한다. 그래야만 쿠키가 비효율적 여러가지 값으로 전달되거나 , 쿠키이름이 같아서 충돌이 나는 상황을 회피할수있다.

옵션을 사용해보도록 하자 쿠키를 사용할때 그 URL에 관련된 서블릿에만 그값이 전달하도록하자
지난번에 한것은 아무런 옵션을 설정하지않았다.

value라는 쿠키에대해서 값을 설정할때 setPath라는게있다. setPath: 이 쿠키가 어느 경우에 사용자로부터 전달되어야하는지에 대한 경로
ex) valueCookie.setPath("/");			// 이렇게 루트로 지정한 경우에는 모든 페이지를 요청할떄마다 이밸류쿠키를 가져와라
ex) valueCookie.setPath("/notice/");		// notice가 포함된 하위 url요청할때 밸류쿠키를 가져옴

테스트해보기위해서 Path를 / 로 테스트해보자 
-Calc2.html

			Cookie valueCookie= new Cookie("value", String.valueOf(v));								//1. 심는것이니까 여기서 부터 시작 Cookie를 키와 밸류값으로 각각 value와 op를 주자 빨간줄이 뜨는데 그이유는 op는 문자열 v는 정수형이어서다 그래서 문자열로 변환해주는 메소드인 String.valueOf(v)를 사용해주자 쿠키로 보낼수있는값은 문자열만 가능하기때문 문자열중에서도 UTF로 보내야한다. 쿠키라는 녀석은 문자열로만 저장하는 한계가있지만 JSON XML을 이용하면 다양한형태로 저장가능
			Cookie opCookie= new Cookie("op",op);
			valueCookie.setPath("/");
			opCookie.setPath("/");			
			response.addCookie(valueCookie);											//2-1. 쿠키 두개를 만들었을 뿐이고클라이언트에게 보내기위해서 addCookie()메소드를 사용하자
			response.addCookie(opCookie);

이렇게 설정을하게되면 어떠한 서비스를 요청을하던 이 밸류값하고 op값을 무조건 전달되게 되있다. 서버를 실행하고 F12키를 눌러서 네트워크를 확인해보자
계산기 html 을 이용해서 Cookie를 생성할것이다. 3을 입력하고 +버튼을 누르면 오퍼레이터값하고 밸류값이 응답으로 올것이다.

헤더정보가 있다 범주가있는데 General Header와 Response Header가있다.

Response Header: 서버가 클라이언트에게 돌려주는 그러한 정보 메타데이터가있다. 

Reequest 헤더에 SetCookie도 있다. value=3;Path=/ 와 op=+; Path=/ 두가지 옵션이 설정된 상태에서 쿠키가 왔다.

그러면 확인해봐야하는게 크롬>설정>쿠키>localhost를 클릭해보면 JSESSIONID ,op,value 다있다.
클릭해서 확인해보면 경로,생성된날짜,시간,만료(브라우저 닫을때) 등등 설정을 볼수있었다.

그리고 5를 입력하고 =버튼을 클릭해보면 Calc2가 전달되면서 Request헤더를 확인해봐야한다 왜냐하면 쿠키를 가져가는지 확인해보기 위해서이다.
Cookie: value=3; op=+;//	 잘 전달이된것을 볼수있다. 따라서 내가 요청하면서 이쿠키를 가져가고있는것이다 그래서 서버가 사용이 가능했던 것이다.

이번에는 add로 Path를 바꿔서 실험해보자 ,이렇게하면 우리 주소와 안맞는다 . 이 쿠키는 add라는 주소를 요청할때만 가게되는것이다,
실험에 앞서서 우리가 사용했던 쿠키를 제거하기위해서 쿠키를 삭제하자. 이제 쿠키가 지워졌기때문에 쿠키를 다시 심을것인데

-Calc2.html
			valueCookie.setPath("/add");
			opCookie.setPath("/add");

5를 누르고 +버튼을 눌러보자. 그리고 Response Headers를 확인해보면 Set-Cookie: value=5; Path=/add Set-Cookie: value=op+; Path=/add 라고 되어있다.
경로가 add라고 되어있는데 그러면 이 add라는  url 을 요청해야만 쿠키가 가는것이다.

6을누르고 = 버튼을 눌러보자 쿠키가 갈까 안갈까? -6이 나온다 쿠키가 안가서 그렇다. 확인해보면 Request Header에 값이 가야하는데 한가지밖에 안가고있다. 
그러면 localhost:8080/add라는 url에 접속해서 요청해보자
페이지는 오류나서 안뜨지만 add라는 요청을 하게됬으니까 주소로갈때 요청하면서 쿠키를 가져왔는지 보려고하는것이다.
Request Headers를 확인해보니까 Cookie:value=5; op+; 쿠키가 제대로갔다.

따라서 경로라는 녀석을 요청할때만 쿠키를 가져올수있도록 제한을 걸수가 있는것이다. 만약에 쿠키를 사용할때 Calc2에서만 사용을한다면 SetPath("/Calc2");로 설정해서 Calc2로만 받을수있게 하는것이 좋고
전체에서 사용이되는거라면 SetPath("/"); 로 설정해서 전체에서 가질수 있게 한다거나 특정경로(notice) 안에서 사용하고싶다면 SetPath("/notice/");를 해서 Notice안에있는 모든것들에게 쿠키를 전달할수 있다. 
그래서 쿠키를 적절하게 설정하게되면 효과적으로 쿠키를 사용할수 있게될것이다.

오늘은 쿠키의 옵션중에서 경로라는 옵션을 알아보았고 다음시간에는 TimeOut이라는 옵션을 알아볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

31 Cookie의 maxAge 옵션

쿠키의 또다른옵션인 maxAge를알아보자, 쿠키는 브라우저에 저장하는 혹은 클라이언트에 저장하는 데이터로써 그 데이터를 브라우저 요청할때 항상 가지고오는 데이터이다.
브라우저가 닫혔다고 가정해보자 쿠키는 어떻게 될까? 만약에 쿠키에다가 maxAge라는 값을 설정하지 않으면 브라우저의 생존주기와 같아진다. 브라우저가 메모리상에 가지고있다가 브라우저가 닫히게되면 같이 날라간다
그런데 쿠키의 큰장점은 브라우저가 닫혀도 내가 원하는 기간을 설정하게 되면 그 기간내에는 그 값을 계속 유지하게 해주는 그런 특징을 가지고있다. 
브라우저가 닫혔는데 어떻게 그것을 유지할까? 브라우저마다 다르긴하지만 쿠키는 브라우저 메모리에있다가 기간설정이나 maxAge 설정이되면 그 녀석이 브라우저와 상관없이 그 기간내에 존재할수 있어야하기때문에
외부파일 영구저장소라할수있는 외부파일에 저장된다. 익스플로러에는 폴더에 저장이된다.

예제를 보자 기존에는 Path만 설정을 했는데 MaxAge를 설정해보자
setMaxAge("인자") : 인자에는 만료날짜가 들어간다 어떤날짜냐면 ex) 1000이라하면 앞으로 천초후에 만료된다. 근데 초단위로하면 감이 잘안오기 때문에
setMaxAge(24*60*60); 이런식으로 시간 분 초 등등 보기 쉽게 날짜를 확인이 가능하게 쓸수도있다.(이방법이 일반적)
설정되는 시간은 만료날짜이다. 이걸 보내게되면 하루동안은 브라우저가 닫히고 클라이언트 컴퓨터가 꺼져도 하루동안은 다음 요청이들어오면 이 쿠키값을 가지고올수있게해야한다.


-Calc2.html

			Cookie valueCookie= new Cookie("value", String.valueOf(v));
			Cookie opCookie= new Cookie("op",op);
			valueCookie.setPath("/calc2");
			valueCookie.setMaxAge(60*60);				//value쿠키는 브라우저를 닫아도 쿠키가 하루동안 사라지지않는다.
			opCookie.setPath("/calc2");					//op쿠키는 설정 안했음으로	브라우저가 닫히면 쿠키가 사라진다.	
			response.addCookie(valueCookie);	
			response.addCookie(opCookie);

이렇게 localhost의 쿠키를 확인해보면 valueCookie는 생성날짜와 만료날짜가 정확히 24시간 하루차이나지만
opCookie는 만료날짜가 정해지지 않은것을 확인 할수 있다.
valueCookie는 하루가 지날때까지 남아있어야함으로 디스크의 파일로 남게 된다 반면에 만료날짜가없으면 브라우저가 닫힐때 사라진다.

만료날짜 중요하다. 만료날짜에 따라서 쿠키를 사용할수있다없다를 정할수 있기 때문이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

32 Application/Session/Cookie 정리 

Application Session Cookie 차이점을 정리해보자

Application에다가 값을 저장하겠다 라고 하면 
사용범위: 그 값을 전역범위에서 쓰겠다 라는것이고 
생명주기: WAS라는녀석이 시작해서 WAS가 종료될때까지 그녀석이 Application안에 존재할수 있도록 하겠다라는뜻이다.
존재위치: Application은 서버쪽의 자원을 쓰기때문에 서버에다가 둔다.

Session 범위를 제한해서 특정사용자만 사용할수 있는 공간을 두겠다 세션저장소는 서버에서 제공하는 저장공간을 사용한다.
사용범위: 세션범위에서 사용하겠다라고 할때 사용한다.. 
생명주기: 세션이 시작해서 종료할때까지
저장위치: 서버에서 제공하는 저장공간을 사용한다.

Cookie 
사용범위: Web Browser별 지정한 path라는 범주 공간에서만 값을 나눠서 쓸수있고,특정 url만 한해서 데이터 사용할수 있다
생명주기: 만료시간을 무한으로 가져갈수있다. 클라이언트가 데이터를 가질수있다는 특징이있다. 
존재위치: 웹브라우저를 쓰기때문에 서버자원을 빌리지않는다.  서버에다가 부담을 주지않는 그런 데이터 구조이다.

quiz)만약에 값을 저장하려고 한다. count라고하는 변수와 거기에 3이라고 값을 저장하려고하는데 오래가져가려면 (ex1년) 어디에다가 저장?
a)cookie -기간이 길면 쿠키다 세션의 공간을 1년이라는 기간을 둘수가 없다. 그렇게 된다고 하더라도 세션이라고해당하는공간을 사용자가 사용할수 없다.

우리가 데이터가 세션타임아웃시간을 넘어서는 기간을 가진다고하면 cookie를 사용해야한다.

quiz) 노티스와 관련된 데이터를 갖고있다. 노티스 외에는 그 데이터를 쓸만한 서블릿이없다. 어디다 저장할까?
a) cookie- 특정 범위 특정url에서만 사용하면 url이 바람직하다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

33 서버에서 페이지 전환해주기(redirection)

굉장히 간단하지만 굉장히 많이쓰는 내용이다. Redirect라는 내용이다.
Redircet:서버에서 페이지를 전해주는 기능

계산기를 만들면서 3이라는값과 +를 누르게되면 그값이 WAS 안에 Servlet(/calc2)에 Post가 된다.  Post가 되면 얘를 돌려주는것은 아무것도없다. 그래서 백지인페이지가 되는것이다. 계속 계산을 이어가고싶다 라고하면 뒤로가기를 눌렀었다.
그래서 다시요청해서 과거상태로 돌아갔었다. 사실 엄밀히 말하면 요청이 아닌데 요청을 하는방식이라고하거나 이페이지로 와야한다. 하지만 서버쪽에서 백지를 주지않고 사용자가 요구한 페이지를 위쪽에서 calc.html을 돌려줄수 있다.
백지가 되는것이아니라 calc.html을 요청한것처럼 보이게 할 수 있다.

계산하는 조건문에서 사용자의 불러주는 페이지가 있다. 이 문구가 돌려주는것이다.
response.getWriter().printf("result is %d", result);

값과 오퍼레이션을 단순하게 저장하는 로직에서는 아무것도 없다. 그래서 사용자가 백지를 받게되는것이다. 백지를 받지않고

else {

			Cookie valueCookie= new Cookie("value", String.valueOf(v));					
			Cookie opCookie= new Cookie("op",op);
			valueCookie.setPath("/calc2");
			valueCookie.setMaxAge(24*60*60);
			opCookie.setPath("/calc2");
			response.addCookie(valueCookie);											
			response.addCookie(opCookie);												
	
			response.sendRedirect("calc2.html");				//백지를 받지않기위해서 사용자가 돌려줄때 response.라는 출력도구중에는 sendRedirect()라는게 있다 여기서 다른페이지로 전환할수있는것이다. 

서버를 재실행해보자 정상적으로 작동이 되고 3+를 눌러보면 html페이지가 새로요청이 된것이다. 주소를 봐도 알겠지만 calc2.html이 된것이다. 
사용자는 이 html 페이지를 요청한적이 없는데 우리가 지정을 response.sendRedirect("calc2.html"); 해주니까 사용자가 요청을 해준것처럼 보이게 된것이다. 
이것이 바로 Redirection이다 이 기능은 앞으로 많이 쓴다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


